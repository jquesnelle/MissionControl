/**********************************************************
 *            AUTOGENERATED FILE                          *
 *             DO NOT MODIFY IT                           *
 *                                                        *
 * To add new commands :                                  *
 *  - Modify ../Xml/commands.xml file                     *
 *  - Re-run generateFeatureControllers.py script         *
 *                                                        *
 **********************************************************/

/**
* @file ARCONTROLLER_Feature.c
* @brief Feature controller allow to send command related of a Feature.
*/

#include <stdio.h>
#include <libARSAL/ARSAL_Mutex.h>
#include <libARCommands/ARCommands.h>
#include <libARController/ARCONTROLLER_Network.h>
#include <libARController/ARCONTROLLER_Feature.h>

#include "ARCONTROLLER_Feature.h"

#define ARCONTROLLER_FEATURE_TAG "ARCONTROLLER_Feature"

void ARCONTROLLER_Feature_DeleteCommandsDictionary (ARCONTROLLER_DICTIONARY_COMMANDS_t **dictionary)
{
    // -- Delete a commands dictionary --
    
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdTmp = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictTmp = NULL;
    
    if (dictionary != NULL)
    {
        if ((*dictionary) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictionary), dictCmdElement, dictCmdTmp)
            {
                // Free the hash table contents
                HASH_ITER(hh, dictCmdElement->elements, dictElement, dictTmp)
                {
                    // for each element
                    
                    if (dictElement->arguments != NULL)
                    {
                        // delete all arguments
                        ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(dictElement->arguments));
                    }
                    
                    if (dictElement->key != NULL)
                    {
                        // free the key of the element
                        free (dictElement->key);
                        dictElement->key = NULL;
                    }
                    
                    HASH_DEL (dictCmdElement->elements, dictElement);
                    free (dictElement);
                    dictElement = NULL;
                }
                
                HASH_DEL ((*dictionary), dictCmdElement);
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
            
            free (*dictionary);
            (*dictionary) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_DeleteArgumentsDictionary (ARCONTROLLER_DICTIONARY_ARG_t **dictionary)
{
    // -- Delete arguments dictionary --
    
    ARCONTROLLER_DICTIONARY_ARG_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ARG_t *dictTmp = NULL;
    
    if (dictionary != NULL)
    {
        if ((*dictionary) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictionary), dictElement, dictTmp)
            {
                /* for each element of the arguments dictionary */
                if ((dictElement->valueType == ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING) && (dictElement->value.String != NULL))
                {
                    free (dictElement->value.String);
                    dictElement->value.String = NULL;
                }
                
                HASH_DEL((*dictionary), dictElement);
                free(dictElement);
                dictElement = NULL;
            }
            
            free (*dictionary);
            (*dictionary) = NULL;
        }
    }
}

/*******************************
 * --- FEATURE ARDrone3 --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/





const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechangedv2_error";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_ardrone3_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordevent_pictureeventchanged_error";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_ardrone3_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordevent_videoeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_flyingstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_alertstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_navigatehomestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON = "arcontroller_dictionary_key_ardrone3_pilotingstate_navigatehomestatechanged_reason";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedx";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedz";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_roll";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_pitch";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_yaw";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_autotakeoffmodechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_altitudechanged_altitude";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_absolutcontrolchanged_on";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_noflyovermaxdistancechanged_shouldnotflyover";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_hullprotectionchanged_present";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_outdoorchanged_outdoor";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_MOTOR_NUMBER = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_motor_number";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_SOFTWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_HARDWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_hardware";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productgpsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productgpsversionchanged_hardware";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORIDS = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorstatechanged_motorids";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorstatechanged_motorerror";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED_VERSION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorsoftwareversionchanged_version";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_NBFLIGHTS = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_nbflights";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_LASTFLIGHTDURATION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_lastflightduration";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_TOTALFLIGHTDURATION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_totalflightduration";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorlasterrorchanged_motorerror";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID_SERIALID = "arcontroller_dictionary_key_ardrone3_settingsstate_p7id_serialid";




const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_pictureformatchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_autowhitebalancechanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_value";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_value";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_enabled";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_INTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_interval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MININTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_mininterval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MAXINTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_maxinterval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoautorecordchanged_enabled";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoautorecordchanged_mass_storage_id";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_mediastreamingstate_videoenablechanged_enabled";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED_FIXED = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_gpsfixstatechanged_fixed";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_gpsupdatestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_hometypechanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_returnhomedelaychanged_delay";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_orientation_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_orientation_pan";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY = "arcontroller_dictionary_key_ardrone3_antiflickeringstate_electricfrequencychanged_frequency";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_antiflickeringstate_modechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE = "arcontroller_dictionary_key_ardrone3_gpsstate_numberofsatellitechanged_numberofsatellite";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypeavailabilitychanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypeavailabilitychanged_available";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypechosenchanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES = "arcontroller_dictionary_key_ardrone3_prostate_features_features";

ARCONTROLLER_FEATURE_ARDrone3_t *ARCONTROLLER_FEATURE_ARDrone3_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_ARDrone3_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingFlatTrim = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingFlatTrim;
            featureController->sendPilotingTakeOff = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingTakeOff;
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDRoll;
            featureController->setPilotingPCMDPitch = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPitch;
            featureController->setPilotingPCMDYaw = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDYaw;
            featureController->setPilotingPCMDGaz = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDGaz;
            featureController->setPilotingPCMDPsi = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPsi;
            featureController->sendPilotingLanding = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingLanding;
            featureController->sendPilotingEmergency = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingEmergency;
            featureController->sendPilotingNavigateHome = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingNavigateHome;
            featureController->sendPilotingAutoTakeOffMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingAutoTakeOffMode;
            featureController->sendAnimationsFlip = ARCONTROLLER_FEATURE_ARDrone3_SendAnimationsFlip;
            featureController->sendCameraOrientation = ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientation;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPicture;
            featureController->sendMediaRecordVideo = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideo;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideoV2;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiAuthChannel;
            featureController->sendPilotingSettingsMaxAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxAltitude;
            featureController->sendPilotingSettingsMaxTilt = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxTilt;
            featureController->sendPilotingSettingsAbsolutControl = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsAbsolutControl;
            featureController->sendPilotingSettingsMaxDistance = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxDistance;
            featureController->sendPilotingSettingsNoFlyOverMaxDistance = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsNoFlyOverMaxDistance;
            featureController->sendSpeedSettingsMaxVerticalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxVerticalSpeed;
            featureController->sendSpeedSettingsMaxRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxRotationSpeed;
            featureController->sendSpeedSettingsHullProtection = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsHullProtection;
            featureController->sendSpeedSettingsOutdoor = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsOutdoor;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSelection;
            featureController->sendPictureSettingsPictureFormatSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsPictureFormatSelection;
            featureController->sendPictureSettingsAutoWhiteBalanceSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsAutoWhiteBalanceSelection;
            featureController->sendPictureSettingsExpositionSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsExpositionSelection;
            featureController->sendPictureSettingsSaturationSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsSaturationSelection;
            featureController->sendPictureSettingsTimelapseSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsTimelapseSelection;
            featureController->sendPictureSettingsVideoAutorecordSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoAutorecordSelection;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoEnable;
            featureController->sendGPSSettingsSetHome = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSetHome;
            featureController->sendGPSSettingsResetHome = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsResetHome;
            featureController->sendGPSSettingsSendControllerGPS = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSendControllerGPS;
            featureController->sendGPSSettingsHomeType = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsHomeType;
            featureController->sendGPSSettingsReturnHomeDelay = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsReturnHomeDelay;
            featureController->sendAntiflickeringElectricFrequency = ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringElectricFrequency;
            featureController->sendAntiflickeringSetMode = ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringSetMode;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->pilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->pilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_ARDrone3_PilotingPCMDParameters_t));
        if (featureController->privatePart == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_ARDrone3_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_ARDrone3_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_ARDrone3_Delete (ARCONTROLLER_FEATURE_ARDrone3_t **feature)
{
    // -- Delete the ARDrone3 feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_ARDrone3_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->pilotingPCMDParameters != NULL)
                {
                    free ((*feature)->privatePart->pilotingPCMDParameters);
                    (*feature)->privatePart->pilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_ARDrone3_GetDictionary (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the ARDrone3 Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_AddCallback (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>ARDrone3</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_RemoveCallback (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>ARDrone3</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_RegisterARCommands (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : MediaRecordState:
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedV2Callback, feature);
        // Commands of class : MediaRecordEvent:
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventVideoEventChangedCallback, feature);
        // Commands of class : PilotingState:
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlatTrimChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateNavigateHomeStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAttitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAutoTakeOffModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAltitudeChangedCallback, feature);
        // Commands of class : NetworkState:
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        // Commands of class : PilotingSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxTiltChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAbsolutControlChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxDistanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback, feature);
        // Commands of class : SpeedSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxVerticalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateHullProtectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateOutdoorChangedCallback, feature);
        // Commands of class : NetworkSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductMotorVersionListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductGPSVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorSoftwareVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorFlightsStatusChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorLastErrorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (&ARCONTROLLER_FEATURE_ARDrone3_SettingsStateP7IDCallback, feature);
        // Commands of class : DirectorModeState:
        // Commands of class : PictureSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStatePictureFormatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateAutoWhiteBalanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateExpositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateSaturationChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateTimelapseChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoAutorecordChangedCallback, feature);
        // Commands of class : MediaStreamingState:
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoEnableChangedCallback, feature);
        // Commands of class : GPSSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateResetHomeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSFixStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSUpdateStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeTypeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateReturnHomeDelayChangedCallback, feature);
        // Commands of class : CameraState:
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (&ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationCallback, feature);
        // Commands of class : AntiflickeringState:
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateElectricFrequencyChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateModeChangedCallback, feature);
        // Commands of class : GPSState:
        ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSStateNumberOfSatelliteChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeAvailabilityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeChosenChangedCallback, feature);
        // Commands of class : PROState:
        ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (&ARCONTROLLER_FEATURE_ARDrone3_PROStateFeaturesCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_UnregisterARCommands (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : MediaRecordState:
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (NULL, NULL);
        // Commands of class : MediaRecordEvent:
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (NULL, NULL);
        // Commands of class : PilotingState:
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (NULL, NULL);
        // Commands of class : NetworkState:
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (NULL, NULL);
        // Commands of class : PilotingSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (NULL, NULL);
        // Commands of class : SpeedSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (NULL, NULL);
        // Commands of class : NetworkSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (NULL, NULL);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (NULL, NULL);
        // Commands of class : DirectorModeState:
        // Commands of class : PictureSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (NULL, NULL);
        // Commands of class : MediaStreamingState:
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (NULL, NULL);
        // Commands of class : GPSSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (NULL, NULL);
        // Commands of class : CameraState:
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (NULL, NULL);
        // Commands of class : AntiflickeringState:
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (NULL, NULL);
        // Commands of class : GPSState:
        ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (NULL, NULL);
        // Commands of class : PROState:
        ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Piloting 
 * All commands related to piloting the totoDrone
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingFlatTrim (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>FlatTrim</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlatTrim command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingFlatTrim(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingTakeOff (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>TakeOff</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingPCMD (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t flag, int8_t roll, int8_t pitch, int8_t yaw, int8_t gaz, float psi)
{
    // -- Send a command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, roll, pitch, yaw, gaz, psi);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMD (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _flag, int8_t _roll, int8_t _pitch, int8_t _yaw, int8_t _gaz, float _psi)
{
    // -- Set the parameter for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->flag = _flag;
        feature->privatePart->pilotingPCMDParameters->roll = _roll;
        feature->privatePart->pilotingPCMDParameters->pitch = _pitch;
        feature->privatePart->pilotingPCMDParameters->yaw = _yaw;
        feature->privatePart->pilotingPCMDParameters->gaz = _gaz;
        feature->privatePart->pilotingPCMDParameters->psi = _psi;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ARDrone3_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->pilotingPCMDParameters->flag, feature->privatePart->pilotingPCMDParameters->roll, feature->privatePart->pilotingPCMDParameters->pitch, feature->privatePart->pilotingPCMDParameters->yaw, feature->privatePart->pilotingPCMDParameters->gaz, feature->privatePart->pilotingPCMDParameters->psi);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->flag = _flag;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->roll = _roll;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPitch (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _pitch)
{
    // -- Set the pitch for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->pitch = _pitch;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDYaw (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _yaw)
{
    // -- Set the yaw for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->yaw = _yaw;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDGaz (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _gaz)
{
    // -- Set the gaz for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->gaz = _gaz;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPsi (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _psi)
{
    // -- Set the psi for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->psi = _psi;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingLanding (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>Landing</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Landing command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingLanding(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingEmergency (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>Emergency</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Emergency command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingEmergency(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingNavigateHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t start)
{
    // -- Send a command <code>NavigateHome</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send NavigateHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingNavigateHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingAutoTakeOffMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t state)
{
    // -- Send a command <code>AutoTakeOffMode</code> of class <code>Piloting</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoTakeOffMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingAutoTakeOffMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: Animations 
 * Animation commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAnimationsFlip (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION direction)
{
    // -- Send a command <code>Flip</code> of class <code>Animations</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Flip command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AnimationsFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: Camera 
 * Ask the drone to move camera
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t tilt, int8_t pan)
{
    // -- Send a command <code>Orientation</code> of class <code>Camera</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Orientation command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, tilt, pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaRecord 
 * Media recording management
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPicture (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>Picture</code> of class <code>MediaRecord</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideo (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD record, uint8_t mass_storage_id)
{
    // -- Send a command <code>Video</code> of class <code>MediaRecord</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PictureV2</code> of class <code>MediaRecord</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>VideoV2</code> of class <code>MediaRecord</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaRecordState 
 * State of media recording
 */

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>PictureStateChanged</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>VideoStateChanged</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PictureStateChangedV2</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>VideoStateChangedV2</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: MediaRecordEvent 
 * Events of media recording
 */

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PictureEventChanged</code> of class <code>MediaRecordEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>VideoEventChanged</code> of class <code>MediaRecordEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: PilotingState 
 * State from drone
 */

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlatTrimChangedCallback (void *customData)
{
    // -- callback used when the command <code>FlatTrimChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLATTRIMCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>FlyingStateChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAlertStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AlertStateChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateNavigateHomeStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason, void *customData)
{
    // -- callback used when the command <code>NavigateHomeStateChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON;
            argDictNewElement->value.I32 = _reason;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePositionChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>PositionChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateSpeedChangedCallback (float _speedX, float _speedY, float _speedZ, void *customData)
{
    // -- callback used when the command <code>SpeedChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX;
            argDictNewElement->value.Float = _speedX;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY;
            argDictNewElement->value.Float = _speedY;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ;
            argDictNewElement->value.Float = _speedZ;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAttitudeChangedCallback (float _roll, float _pitch, float _yaw, void *customData)
{
    // -- callback used when the command <code>AttitudeChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL;
            argDictNewElement->value.Float = _roll;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH;
            argDictNewElement->value.Float = _pitch;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW;
            argDictNewElement->value.Float = _yaw;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAutoTakeOffModeChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>AutoTakeOffModeChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAltitudeChangedCallback (double _altitude, void *customData)
{
    // -- callback used when the command <code>AltitudeChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Network 
 * Network related commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiScan (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>WifiScan</code> of class <code>Network</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>WifiAuthChannel</code> of class <code>Network</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: NetworkState 
 * Network state from Product
 */

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiScanListChangedCallback (char * _ssid, int16_t _rssi, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>WifiScanListChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllWifiScanChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFISCANCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>WifiAuthChannelListChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", HASH_COUNT (dictCmdElement->elements));
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", HASH_COUNT (dictCmdElement->elements));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllWifiAuthChannelChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: PilotingSettings 
 * Piloting Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>MaxAltitude</code> of class <code>PilotingSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxTilt (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>MaxTilt</code> of class <code>PilotingSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxTilt command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxTilt(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsAbsolutControl (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t on)
{
    // -- Send a command <code>AbsolutControl</code> of class <code>PilotingSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AbsolutControl command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsAbsolutControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, on);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxDistance (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>MaxDistance</code> of class <code>PilotingSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxDistance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxDistance(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsNoFlyOverMaxDistance (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t shouldNotFlyOver)
{
    // -- Send a command <code>NoFlyOverMaxDistance</code> of class <code>PilotingSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send NoFlyOverMaxDistance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsNoFlyOverMaxDistance(cmdBuffer, sizeof(cmdBuffer), &cmdSize, shouldNotFlyOver);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: PilotingSettingsState 
 * Piloting Settings state from product
 */

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxAltitudeChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxTiltChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxTiltChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAbsolutControlChangedCallback (uint8_t _on, void *customData)
{
    // -- callback used when the command <code>AbsolutControlChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON;
            argDictNewElement->value.U8 = _on;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxDistanceChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxDistanceChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (uint8_t _shouldNotFlyOver, void *customData)
{
    // -- callback used when the command <code>NoFlyOverMaxDistanceChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER;
            argDictNewElement->value.U8 = _shouldNotFlyOver;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: SpeedSettings 
 * Speed Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>MaxVerticalSpeed</code> of class <code>SpeedSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>MaxRotationSpeed</code> of class <code>SpeedSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsHullProtection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t present)
{
    // -- Send a command <code>HullProtection</code> of class <code>SpeedSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send HullProtection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsHullProtection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, present);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsOutdoor (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>Outdoor</code> of class <code>SpeedSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Outdoor command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsOutdoor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: SpeedSettingsState 
 * Speed Settings state from product
 */

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxVerticalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxVerticalSpeedChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxRotationSpeedChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateHullProtectionChangedCallback (uint8_t _present, void *customData)
{
    // -- callback used when the command <code>HullProtectionChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT;
            argDictNewElement->value.U8 = _present;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateOutdoorChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>OutdoorChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: NetworkSettings 
 * Network settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>WifiSelection</code> of class <code>NetworkSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: NetworkSettingsState 
 * Network settings state from product
 */

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>WifiSelectionChanged</code> of class <code>NetworkSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Settings 
 * Settings commands
 */

/**
 * class: SettingsState 
 * Settings state from product
 */

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductMotorVersionListChangedCallback (uint8_t _motor_number, char * _type, char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>ProductMotorVersionListChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _motor_number);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _motor_number);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_MOTOR_NUMBER;
            argDictNewElement->value.U8 = _motor_number;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_TYPE;
            strLength = strlen (_type);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _type, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductGPSVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>ProductGPSVersionChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorStateChangedCallback (uint8_t _motorIds, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError, void *customData)
{
    // -- callback used when the command <code>MotorErrorStateChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORIDS;
            argDictNewElement->value.U8 = _motorIds;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR;
            argDictNewElement->value.I32 = _motorError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorSoftwareVersionChangedCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>MotorSoftwareVersionChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorFlightsStatusChangedCallback (uint16_t _nbFlights, uint16_t _lastFlightDuration, uint32_t _totalFlightDuration, void *customData)
{
    // -- callback used when the command <code>MotorFlightsStatusChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_NBFLIGHTS;
            argDictNewElement->value.U16 = _nbFlights;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_LASTFLIGHTDURATION;
            argDictNewElement->value.U16 = _lastFlightDuration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_TOTALFLIGHTDURATION;
            argDictNewElement->value.U32 = _totalFlightDuration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorLastErrorChangedCallback (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError, void *customData)
{
    // -- callback used when the command <code>MotorErrorLastErrorChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR;
            argDictNewElement->value.I32 = _motorError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateP7IDCallback (char * _serialID, void *customData)
{
    // -- callback used when the command <code>P7ID</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID_SERIALID;
            strLength = strlen (_serialID);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serialID, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: DirectorMode 
 * Director mode commands
 */

/**
 * class: DirectorModeState 
 * Director mode state from product
 */

/**
 * class: PictureSettings 
 * Photo settings chosen by the user
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsPictureFormatSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE type)
{
    // -- Send a command <code>PictureFormatSelection</code> of class <code>PictureSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureFormatSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsPictureFormatSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsAutoWhiteBalanceSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE type)
{
    // -- Send a command <code>AutoWhiteBalanceSelection</code> of class <code>PictureSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoWhiteBalanceSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsAutoWhiteBalanceSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsExpositionSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>ExpositionSelection</code> of class <code>PictureSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ExpositionSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsExpositionSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsSaturationSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>SaturationSelection</code> of class <code>PictureSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SaturationSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsSaturationSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsTimelapseSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enabled, float interval)
{
    // -- Send a command <code>TimelapseSelection</code> of class <code>PictureSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TimelapseSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsTimelapseSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled, interval);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoAutorecordSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enabled, uint8_t mass_storage_id)
{
    // -- Send a command <code>VideoAutorecordSelection</code> of class <code>PictureSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoAutorecordSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoAutorecordSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: PictureSettingsState 
 * Photo settings state from product
 */

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStatePictureFormatChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>PictureFormatChanged</code> of class <code>PictureSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateAutoWhiteBalanceChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>AutoWhiteBalanceChanged</code> of class <code>PictureSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateExpositionChangedCallback (float _value, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>ExpositionChanged</code> of class <code>PictureSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateSaturationChangedCallback (float _value, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SaturationChanged</code> of class <code>PictureSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateTimelapseChangedCallback (uint8_t _enabled, float _interval, float _minInterval, float _maxInterval, void *customData)
{
    // -- callback used when the command <code>TimelapseChanged</code> of class <code>PictureSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_INTERVAL;
            argDictNewElement->value.Float = _interval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MININTERVAL;
            argDictNewElement->value.Float = _minInterval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MAXINTERVAL;
            argDictNewElement->value.Float = _maxInterval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoAutorecordChangedCallback (uint8_t _enabled, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>VideoAutorecordChanged</code> of class <code>PictureSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: MediaStreaming 
 * Control media streaming behavior.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enable)
{
    // -- Send a command <code>VideoEnable</code> of class <code>MediaStreaming</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaStreamingState 
 * Media streaming status.
 */

void ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>VideoEnableChanged</code> of class <code>MediaStreamingState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: GPSSettings 
 * GPS settings
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSetHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude)
{
    // -- Send a command <code>SetHome</code> of class <code>GPSSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsSetHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsResetHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>ResetHome</code> of class <code>GPSSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsResetHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSendControllerGPS (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy)
{
    // -- Send a command <code>SendControllerGPS</code> of class <code>GPSSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SendControllerGPS command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsSendControllerGPS(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude, horizontalAccuracy, verticalAccuracy);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsHomeType (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE type)
{
    // -- Send a command <code>HomeType</code> of class <code>GPSSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send HomeType command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsHomeType(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsReturnHomeDelay (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t delay)
{
    // -- Send a command <code>ReturnHomeDelay</code> of class <code>GPSSettings</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ReturnHomeDelay command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsReturnHomeDelay(cmdBuffer, sizeof(cmdBuffer), &cmdSize, delay);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: GPSSettingsState 
 * GPS settings state
 */

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>HomeChanged</code> of class <code>GPSSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateResetHomeChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>ResetHomeChanged</code> of class <code>GPSSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSFixStateChangedCallback (uint8_t _fixed, void *customData)
{
    // -- callback used when the command <code>GPSFixStateChanged</code> of class <code>GPSSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED_FIXED;
            argDictNewElement->value.U8 = _fixed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSUpdateStateChangedCallback (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>GPSUpdateStateChanged</code> of class <code>GPSSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeTypeChangedCallback (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>HomeTypeChanged</code> of class <code>GPSSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateReturnHomeDelayChangedCallback (uint16_t _delay, void *customData)
{
    // -- callback used when the command <code>ReturnHomeDelayChanged</code> of class <code>GPSSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY;
            argDictNewElement->value.U16 = _delay;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: CameraState 
 * Camera state
 */

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationCallback (int8_t _tilt, int8_t _pan, void *customData)
{
    // -- callback used when the command <code>Orientation</code> of class <code>CameraState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT;
            argDictNewElement->value.I8 = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN;
            argDictNewElement->value.I8 = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Antiflickering 
 * Anti-flickering related commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringElectricFrequency (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY frequency)
{
    // -- Send a command <code>ElectricFrequency</code> of class <code>Antiflickering</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ElectricFrequency command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AntiflickeringElectricFrequency(cmdBuffer, sizeof(cmdBuffer), &cmdSize, frequency);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringSetMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE mode)
{
    // -- Send a command <code>SetMode</code> of class <code>Antiflickering</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AntiflickeringSetMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: AntiflickeringState 
 * Anti-flickering related states
 */

void ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateElectricFrequencyChangedCallback (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, void *customData)
{
    // -- callback used when the command <code>ElectricFrequencyChanged</code> of class <code>AntiflickeringState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateModeChangedCallback (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>ModeChanged</code> of class <code>AntiflickeringState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: GPSState 
 * GPS related States
 */

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateNumberOfSatelliteChangedCallback (uint8_t _numberOfSatellite, void *customData)
{
    // -- callback used when the command <code>NumberOfSatelliteChanged</code> of class <code>GPSState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE;
            argDictNewElement->value.U8 = _numberOfSatellite;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeAvailabilityChangedCallback (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type, uint8_t _available, void *customData)
{
    // -- callback used when the command <code>HomeTypeAvailabilityChanged</code> of class <code>GPSState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _type);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _type);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE;
            argDictNewElement->value.U8 = _available;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeChosenChangedCallback (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>HomeTypeChosenChanged</code> of class <code>GPSState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: PROState 
 * Pro features enabled on the Bebop
 */

void ARCONTROLLER_FEATURE_ARDrone3_PROStateFeaturesCallback (uint64_t _features, void *customData)
{
    // -- callback used when the command <code>Features</code> of class <code>PROState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES;
            argDictNewElement->value.U64 = _features;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetNetworkController (ARCONTROLLER_FEATURE_ARDrone3_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_GetCommandElements (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE ARDrone3Debug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/



const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3DEBUG_BATTERYDEBUGSETTINGSSTATE_USEDRONE2BATTERYCHANGED_DRONE2BATTERYUSED = "arcontroller_dictionary_key_ardrone3debug_batterydebugsettingsstate_usedrone2batterychanged_drone2batteryused";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3DEBUG_GPSDEBUGSTATE_NBSATELLITECHANGED_NBSATELLITE = "arcontroller_dictionary_key_ardrone3debug_gpsdebugstate_nbsatellitechanged_nbsatellite";

ARCONTROLLER_FEATURE_ARDrone3Debug_t *ARCONTROLLER_FEATURE_ARDrone3Debug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_ARDrone3Debug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3Debug_t));
        if (featureController != NULL)
        {
            featureController->sendVideoEnableWobbleCancellation = ARCONTROLLER_FEATURE_ARDrone3Debug_SendVideoEnableWobbleCancellation;
            featureController->sendVideoSyncAnglesGyros = ARCONTROLLER_FEATURE_ARDrone3Debug_SendVideoSyncAnglesGyros;
            featureController->sendVideoManualWhiteBalance = ARCONTROLLER_FEATURE_ARDrone3Debug_SendVideoManualWhiteBalance;
            featureController->sendBatteryDebugSettingsUseDrone2Battery = ARCONTROLLER_FEATURE_ARDrone3Debug_SendBatteryDebugSettingsUseDrone2Battery;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3Debug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_ARDrone3Debug_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_ARDrone3Debug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_ARDrone3Debug_Delete (ARCONTROLLER_FEATURE_ARDrone3Debug_t **feature)
{
    // -- Delete the ARDrone3Debug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_ARDrone3Debug_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_ARDrone3Debug_GetDictionary (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the ARDrone3Debug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_AddCallback (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>ARDrone3Debug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_RemoveCallback (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>ARDrone3Debug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_RegisterARCommands (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : BatteryDebugSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3DebugBatteryDebugSettingsStateUseDrone2BatteryChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3Debug_BatteryDebugSettingsStateUseDrone2BatteryChangedCallback, feature);
        // Commands of class : GPSDebugState:
        ARCOMMANDS_Decoder_SetARDrone3DebugGPSDebugStateNbSatelliteChangedCallback (&ARCONTROLLER_FEATURE_ARDrone3Debug_GPSDebugStateNbSatelliteChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_UnregisterARCommands (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : BatteryDebugSettingsState:
        ARCOMMANDS_Decoder_SetARDrone3DebugBatteryDebugSettingsStateUseDrone2BatteryChangedCallback (NULL, NULL);
        // Commands of class : GPSDebugState:
        ARCOMMANDS_Decoder_SetARDrone3DebugGPSDebugStateNbSatelliteChangedCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Video 
 * Debug commands for video
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_SendVideoEnableWobbleCancellation (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, uint8_t enable)
{
    // -- Send a command <code>EnableWobbleCancellation</code> of class <code>Video</code> in project <code>ARDrone3Debug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send EnableWobbleCancellation command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3DebugVideoEnableWobbleCancellation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_SendVideoSyncAnglesGyros (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, float anglesDelay_s, float gyrosDelay_s)
{
    // -- Send a command <code>SyncAnglesGyros</code> of class <code>Video</code> in project <code>ARDrone3Debug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SyncAnglesGyros command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3DebugVideoSyncAnglesGyros(cmdBuffer, sizeof(cmdBuffer), &cmdSize, anglesDelay_s, gyrosDelay_s);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_SendVideoManualWhiteBalance (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature)
{
    // -- Send a command <code>ManualWhiteBalance</code> of class <code>Video</code> in project <code>ARDrone3Debug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ManualWhiteBalance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3DebugVideoManualWhiteBalance(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: BatteryDebugSettings 
 * Debug commands for drone3 battery
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_SendBatteryDebugSettingsUseDrone2Battery (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, uint8_t drone2BatteryUsed)
{
    // -- Send a command <code>UseDrone2Battery</code> of class <code>BatteryDebugSettings</code> in project <code>ARDrone3Debug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UseDrone2Battery command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3DebugBatteryDebugSettingsUseDrone2Battery(cmdBuffer, sizeof(cmdBuffer), &cmdSize, drone2BatteryUsed);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: BatteryDebugSettingsState 
 * Debug commands for drone3 battery state
 */

void ARCONTROLLER_FEATURE_ARDrone3Debug_BatteryDebugSettingsStateUseDrone2BatteryChangedCallback (uint8_t _drone2BatteryUsed, void *customData)
{
    // -- callback used when the command <code>UseDrone2BatteryChanged</code> of class <code>BatteryDebugSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature = (ARCONTROLLER_FEATURE_ARDrone3Debug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3DEBUG_BATTERYDEBUGSETTINGSSTATE_USEDRONE2BATTERYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3DEBUG_BATTERYDEBUGSETTINGSSTATE_USEDRONE2BATTERYCHANGED_DRONE2BATTERYUSED;
            argDictNewElement->value.U8 = _drone2BatteryUsed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: GPSDebugState 
 * Debug commands for drone3 gps state
 */

void ARCONTROLLER_FEATURE_ARDrone3Debug_GPSDebugStateNbSatelliteChangedCallback (uint8_t _nbSatellite, void *customData)
{
    // -- callback used when the command <code>NbSatelliteChanged</code> of class <code>GPSDebugState is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature = (ARCONTROLLER_FEATURE_ARDrone3Debug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3DEBUG_GPSDEBUGSTATE_NBSATELLITECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3DEBUG_GPSDEBUGSTATE_NBSATELLITECHANGED_NBSATELLITE;
            argDictNewElement->value.U8 = _nbSatellite;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3Debug_SetNetworkController (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3Debug_GetCommandElements (ARCONTROLLER_FEATURE_ARDrone3Debug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE common --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE = "arcontroller_dictionary_key_common_networkevent_disconnection_cause";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED_NAME = "arcontroller_dictionary_key_common_settingsstate_productnamechanged_name";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_common_settingsstate_productversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_common_settingsstate_productversionchanged_hardware";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED_HIGH = "arcontroller_dictionary_key_common_settingsstate_productserialhighchanged_high";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED_LOW = "arcontroller_dictionary_key_common_settingsstate_productseriallowchanged_low";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED_CODE = "arcontroller_dictionary_key_common_settingsstate_countrychanged_code";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED_AUTOMATIC = "arcontroller_dictionary_key_common_settingsstate_autocountrychanged_automatic";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT = "arcontroller_dictionary_key_common_commonstate_batterystatechanged_percent";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstoragestatelistchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME = "arcontroller_dictionary_key_common_commonstate_massstoragestatelistchanged_name";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_size";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_used_size";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_plugged";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_full";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_internal";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE = "arcontroller_dictionary_key_common_commonstate_currentdatechanged_date";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME = "arcontroller_dictionary_key_common_commonstate_currenttimechanged_time";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_free_space";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_rec_time";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_photo_remaining";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI = "arcontroller_dictionary_key_common_commonstate_wifisignalchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME = "arcontroller_dictionary_key_common_commonstate_sensorsstateslistchanged_sensorname";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE = "arcontroller_dictionary_key_common_commonstate_sensorsstateslistchanged_sensorstate";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE = "arcontroller_dictionary_key_common_overheatstate_overheatregulationchanged_regulationtype";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CONTROLLERSTATE_ISPILOTINGCHANGED_PILOTING = "arcontroller_dictionary_key_common_controllerstate_ispilotingchanged_piloting";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED_OUTDOOR = "arcontroller_dictionary_key_common_wifisettingsstate_outdoorsettingschanged_outdoor";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_filepath";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkplayerrorstatechanged_error";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_xaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_yaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_zaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_calibrationfailed";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationrequiredstate_required";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationaxistocalibratechanged_axis";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstartedchanged_started";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_FOV = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_fov";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMAX = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_panmax";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMIN = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_panmin";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMAX = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_tiltmax";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMIN = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_tiltmin";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE = "arcontroller_dictionary_key_common_flightplanstate_availabilitystatechanged_availabilitystate";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT = "arcontroller_dictionary_key_common_flightplanstate_componentstatelistchanged_component";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE = "arcontroller_dictionary_key_common_flightplanstate_componentstatelistchanged_state";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_controllerlibarcommandsversion_version";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_skycontrollerlibarcommandsversion_version";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_devicelibarcommandsversion_version";

ARCONTROLLER_FEATURE_Common_t *ARCONTROLLER_FEATURE_Common_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Common_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Common_t));
        if (featureController != NULL)
        {
            featureController->sendNetworkDisconnect = ARCONTROLLER_FEATURE_Common_SendNetworkDisconnect;
            featureController->sendSettingsAllSettings = ARCONTROLLER_FEATURE_Common_SendSettingsAllSettings;
            featureController->sendSettingsReset = ARCONTROLLER_FEATURE_Common_SendSettingsReset;
            featureController->sendSettingsProductName = ARCONTROLLER_FEATURE_Common_SendSettingsProductName;
            featureController->sendSettingsCountry = ARCONTROLLER_FEATURE_Common_SendSettingsCountry;
            featureController->sendSettingsAutoCountry = ARCONTROLLER_FEATURE_Common_SendSettingsAutoCountry;
            featureController->sendCommonAllStates = ARCONTROLLER_FEATURE_Common_SendCommonAllStates;
            featureController->sendCommonCurrentDate = ARCONTROLLER_FEATURE_Common_SendCommonCurrentDate;
            featureController->sendCommonCurrentTime = ARCONTROLLER_FEATURE_Common_SendCommonCurrentTime;
            featureController->sendCommonReboot = ARCONTROLLER_FEATURE_Common_SendCommonReboot;
            featureController->sendOverHeatSwitchOff = ARCONTROLLER_FEATURE_Common_SendOverHeatSwitchOff;
            featureController->sendOverHeatVentilate = ARCONTROLLER_FEATURE_Common_SendOverHeatVentilate;
            featureController->sendWifiSettingsOutdoorSetting = ARCONTROLLER_FEATURE_Common_SendWifiSettingsOutdoorSetting;
            featureController->sendMavlinkStart = ARCONTROLLER_FEATURE_Common_SendMavlinkStart;
            featureController->sendMavlinkPause = ARCONTROLLER_FEATURE_Common_SendMavlinkPause;
            featureController->sendMavlinkStop = ARCONTROLLER_FEATURE_Common_SendMavlinkStop;
            featureController->sendCalibrationMagnetoCalibration = ARCONTROLLER_FEATURE_Common_SendCalibrationMagnetoCalibration;
            featureController->sendGPSControllerPositionForRun = ARCONTROLLER_FEATURE_Common_SendGPSControllerPositionForRun;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Common_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_Common_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Common_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Common_Delete (ARCONTROLLER_FEATURE_Common_t **feature)
{
    // -- Delete the common feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_Common_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Common_GetDictionary (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the common Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_AddCallback (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Common</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_RemoveCallback (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Common</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_RegisterARCommands (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : NetworkEvent:
        ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (&ARCONTROLLER_FEATURE_Common_NetworkEventDisconnectionCallback, feature);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateAllSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateResetChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductNameChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialHighChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialLowChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateCountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (&ARCONTROLLER_FEATURE_Common_SettingsStateAutoCountryChangedCallback, feature);
        // Commands of class : CommonState:
        ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateAllStatesChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateBatteryStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateMassStorageStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateCurrentDateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateCurrentTimeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoRemainingListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateWifiSignalChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (&ARCONTROLLER_FEATURE_Common_CommonStateSensorsStatesListChangedCallback, feature);
        // Commands of class : OverHeatState:
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (&ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (&ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatRegulationChangedCallback, feature);
        // Commands of class : ControllerState:
        ARCOMMANDS_Decoder_SetCommonControllerStateIsPilotingChangedCallback (&ARCONTROLLER_FEATURE_Common_ControllerStateIsPilotingChangedCallback, feature);
        // Commands of class : WifiSettingsState:
        ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (&ARCONTROLLER_FEATURE_Common_WifiSettingsStateOutdoorSettingsChangedCallback, feature);
        // Commands of class : MavlinkState:
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (&ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkFilePlayingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (&ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkPlayErrorStateChangedCallback, feature);
        // Commands of class : CalibrationState:
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationRequiredStateCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (&ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStartedChangedCallback, feature);
        // Commands of class : CameraSettingsState:
        ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (&ARCONTROLLER_FEATURE_Common_CameraSettingsStateCameraSettingsChangedCallback, feature);
        // Commands of class : FlightPlanState:
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanStateAvailabilityStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanStateComponentStateListChangedCallback, feature);
        // Commands of class : FlightPlanEvent:
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanEventStartingErrorEventCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (&ARCONTROLLER_FEATURE_Common_FlightPlanEventSpeedBridleEventCallback, feature);
        // Commands of class : ARLibsVersionsState:
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (&ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateControllerLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (&ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateSkyControllerLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (&ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateDeviceLibARCommandsVersionCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_UnregisterARCommands (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : NetworkEvent:
        ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (NULL, NULL);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (NULL, NULL);
        // Commands of class : CommonState:
        ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (NULL, NULL);
        // Commands of class : OverHeatState:
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (NULL, NULL);
        // Commands of class : ControllerState:
        ARCOMMANDS_Decoder_SetCommonControllerStateIsPilotingChangedCallback (NULL, NULL);
        // Commands of class : WifiSettingsState:
        ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (NULL, NULL);
        // Commands of class : MavlinkState:
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (NULL, NULL);
        // Commands of class : CalibrationState:
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (NULL, NULL);
        // Commands of class : CameraSettingsState:
        ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (NULL, NULL);
        // Commands of class : FlightPlanState:
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (NULL, NULL);
        // Commands of class : FlightPlanEvent:
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (NULL, NULL);
        // Commands of class : ARLibsVersionsState:
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Network 
 * Network related commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendNetworkDisconnect (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>Disconnect</code> of class <code>Network</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Disconnect command
        cmdError = ARCOMMANDS_Generator_GenerateCommonNetworkDisconnect(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: NetworkEvent 
 * Network Event from product
 */

void ARCONTROLLER_FEATURE_Common_NetworkEventDisconnectionCallback (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause, void *customData)
{
    // -- callback used when the command <code>Disconnection</code> of class <code>NetworkEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE;
            argDictNewElement->value.I32 = _cause;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Settings 
 * Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsAllSettings (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>AllSettings</code> of class <code>Settings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsReset (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>Reset</code> of class <code>Settings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsProductName (ARCONTROLLER_FEATURE_Common_t *feature, char * name)
{
    // -- Send a command <code>ProductName</code> of class <code>Settings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ProductName command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsProductName(cmdBuffer, sizeof(cmdBuffer), &cmdSize, name);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsCountry (ARCONTROLLER_FEATURE_Common_t *feature, char * code)
{
    // -- Send a command <code>Country</code> of class <code>Settings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Country command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, code);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsAutoCountry (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t automatic)
{
    // -- Send a command <code>AutoCountry</code> of class <code>Settings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoCountry command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsAutoCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, automatic);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: SettingsState 
 * Settings state from product
 */

void ARCONTROLLER_FEATURE_Common_SettingsStateAllSettingsChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllSettingsChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_ALLSETTINGSCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateResetChangedCallback (void *customData)
{
    // -- callback used when the command <code>ResetChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_RESETCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductNameChangedCallback (char * _name, void *customData)
{
    // -- callback used when the command <code>ProductNameChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>ProductVersionChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialHighChangedCallback (char * _high, void *customData)
{
    // -- callback used when the command <code>ProductSerialHighChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED_HIGH;
            strLength = strlen (_high);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _high, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialLowChangedCallback (char * _low, void *customData)
{
    // -- callback used when the command <code>ProductSerialLowChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED_LOW;
            strLength = strlen (_low);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _low, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateCountryChangedCallback (char * _code, void *customData)
{
    // -- callback used when the command <code>CountryChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED_CODE;
            strLength = strlen (_code);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _code, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_SettingsStateAutoCountryChangedCallback (uint8_t _automatic, void *customData)
{
    // -- callback used when the command <code>AutoCountryChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED_AUTOMATIC;
            argDictNewElement->value.U8 = _automatic;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Common 
 * Common commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonAllStates (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>AllStates</code> of class <code>Common</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllStates command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonAllStates(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonCurrentDate (ARCONTROLLER_FEATURE_Common_t *feature, char * date)
{
    // -- Send a command <code>CurrentDate</code> of class <code>Common</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CurrentDate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonCurrentDate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, date);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonCurrentTime (ARCONTROLLER_FEATURE_Common_t *feature, char * time)
{
    // -- Send a command <code>CurrentTime</code> of class <code>Common</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CurrentTime command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonCurrentTime(cmdBuffer, sizeof(cmdBuffer), &cmdSize, time);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonReboot (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>Reboot</code> of class <code>Common</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reboot command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonReboot(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: CommonState 
 * Common state from product
 */

void ARCONTROLLER_FEATURE_Common_CommonStateAllStatesChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllStatesChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_ALLSTATESCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateBatteryStateChangedCallback (uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>BatteryStateChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageStateListChangedCallback (uint8_t _mass_storage_id, char * _name, void *customData)
{
    // -- callback used when the command <code>MassStorageStateListChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoStateListChangedCallback (uint8_t _mass_storage_id, uint32_t _size, uint32_t _used_size, uint8_t _plugged, uint8_t _full, uint8_t _internal, void *customData)
{
    // -- callback used when the command <code>MassStorageInfoStateListChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE;
            argDictNewElement->value.U32 = _size;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE;
            argDictNewElement->value.U32 = _used_size;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED;
            argDictNewElement->value.U8 = _plugged;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL;
            argDictNewElement->value.U8 = _full;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL;
            argDictNewElement->value.U8 = _internal;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateCurrentDateChangedCallback (char * _date, void *customData)
{
    // -- callback used when the command <code>CurrentDateChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE;
            strLength = strlen (_date);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _date, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateCurrentTimeChangedCallback (char * _time, void *customData)
{
    // -- callback used when the command <code>CurrentTimeChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME;
            strLength = strlen (_time);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _time, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoRemainingListChangedCallback (uint32_t _free_space, uint16_t _rec_time, uint32_t _photo_remaining, void *customData)
{
    // -- callback used when the command <code>MassStorageInfoRemainingListChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", HASH_COUNT (dictCmdElement->elements));
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", HASH_COUNT (dictCmdElement->elements));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE;
            argDictNewElement->value.U32 = _free_space;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME;
            argDictNewElement->value.U16 = _rec_time;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING;
            argDictNewElement->value.U32 = _photo_remaining;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateWifiSignalChangedCallback (int16_t _rssi, void *customData)
{
    // -- callback used when the command <code>WifiSignalChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CommonStateSensorsStatesListChangedCallback (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName, uint8_t _sensorState, void *customData)
{
    // -- callback used when the command <code>SensorsStatesListChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _sensorName);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _sensorName);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME;
            argDictNewElement->value.I32 = _sensorName;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE;
            argDictNewElement->value.U8 = _sensorState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: OverHeat 
 * Over heat commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendOverHeatSwitchOff (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>SwitchOff</code> of class <code>OverHeat</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SwitchOff command
        cmdError = ARCOMMANDS_Generator_GenerateCommonOverHeatSwitchOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendOverHeatVentilate (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>Ventilate</code> of class <code>OverHeat</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Ventilate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonOverHeatVentilate(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: OverHeatState 
 * Overheat state from product
 */

void ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatChangedCallback (void *customData)
{
    // -- callback used when the command <code>OverHeatChanged</code> of class <code>OverHeatState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatRegulationChangedCallback (uint8_t _regulationType, void *customData)
{
    // -- callback used when the command <code>OverHeatRegulationChanged</code> of class <code>OverHeatState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE;
            argDictNewElement->value.U8 = _regulationType;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: ControllerState 
 * Notify the device about the state of the controller application.
 */

void ARCONTROLLER_FEATURE_Common_ControllerStateIsPilotingChangedCallback (uint8_t _piloting, void *customData)
{
    // -- callback used when the command <code>IsPilotingChanged</code> of class <code>ControllerState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CONTROLLERSTATE_ISPILOTINGCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CONTROLLERSTATE_ISPILOTINGCHANGED_PILOTING;
            argDictNewElement->value.U8 = _piloting;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: WifiSettings 
 * Wifi settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendWifiSettingsOutdoorSetting (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>OutdoorSetting</code> of class <code>WifiSettings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send OutdoorSetting command
        cmdError = ARCOMMANDS_Generator_GenerateCommonWifiSettingsOutdoorSetting(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: WifiSettingsState 
 * Wifi settings state from product
 */

void ARCONTROLLER_FEATURE_Common_WifiSettingsStateOutdoorSettingsChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>OutdoorSettingsChanged</code> of class <code>WifiSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Mavlink 
 * Mavlink flight plans commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkStart (ARCONTROLLER_FEATURE_Common_t *feature, char * filepath, eARCOMMANDS_COMMON_MAVLINK_START_TYPE type)
{
    // -- Send a command <code>Start</code> of class <code>Mavlink</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Start command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkStart(cmdBuffer, sizeof(cmdBuffer), &cmdSize, filepath, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkPause (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>Pause</code> of class <code>Mavlink</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Pause command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkPause(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkStop (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>Stop</code> of class <code>Mavlink</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Stop command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MavlinkState 
 * Mavlink flight plans states commands
 */

void ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkFilePlayingStateChangedCallback (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state, char * _filepath, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>MavlinkFilePlayingStateChanged</code> of class <code>MavlinkState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH;
            strLength = strlen (_filepath);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filepath, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkPlayErrorStateChangedCallback (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MavlinkPlayErrorStateChanged</code> of class <code>MavlinkState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Calibration 
 * Calibration commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCalibrationMagnetoCalibration (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t calibrate)
{
    // -- Send a command <code>MagnetoCalibration</code> of class <code>Calibration</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MagnetoCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCalibrationMagnetoCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, calibrate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: CalibrationState 
 * Status of the calibration
 */

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStateChangedCallback (uint8_t _xAxisCalibration, uint8_t _yAxisCalibration, uint8_t _zAxisCalibration, uint8_t _calibrationFailed, void *customData)
{
    // -- callback used when the command <code>MagnetoCalibrationStateChanged</code> of class <code>CalibrationState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION;
            argDictNewElement->value.U8 = _xAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION;
            argDictNewElement->value.U8 = _yAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION;
            argDictNewElement->value.U8 = _zAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED;
            argDictNewElement->value.U8 = _calibrationFailed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationRequiredStateCallback (uint8_t _required, void *customData)
{
    // -- callback used when the command <code>MagnetoCalibrationRequiredState</code> of class <code>CalibrationState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED;
            argDictNewElement->value.U8 = _required;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis, void *customData)
{
    // -- callback used when the command <code>MagnetoCalibrationAxisToCalibrateChanged</code> of class <code>CalibrationState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS;
            argDictNewElement->value.I32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStartedChangedCallback (uint8_t _started, void *customData)
{
    // -- callback used when the command <code>MagnetoCalibrationStartedChanged</code> of class <code>CalibrationState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED;
            argDictNewElement->value.U8 = _started;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: CameraSettingsState 
 * Status of the camera settings
 */

void ARCONTROLLER_FEATURE_Common_CameraSettingsStateCameraSettingsChangedCallback (float _fov, float _panMax, float _panMin, float _tiltMax, float _tiltMin, void *customData)
{
    // -- callback used when the command <code>CameraSettingsChanged</code> of class <code>CameraSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_FOV;
            argDictNewElement->value.Float = _fov;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMAX;
            argDictNewElement->value.Float = _panMax;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMIN;
            argDictNewElement->value.Float = _panMin;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMAX;
            argDictNewElement->value.Float = _tiltMax;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMIN;
            argDictNewElement->value.Float = _tiltMin;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: GPS 
 * GPS related commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendGPSControllerPositionForRun (ARCONTROLLER_FEATURE_Common_t *feature, double latitude, double longitude)
{
    // -- Send a command <code>ControllerPositionForRun</code> of class <code>GPS</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerPositionForRun command
        cmdError = ARCOMMANDS_Generator_GenerateCommonGPSControllerPositionForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: FlightPlanState 
 * FlightPlan state commands
 */

void ARCONTROLLER_FEATURE_Common_FlightPlanStateAvailabilityStateChangedCallback (uint8_t _AvailabilityState, void *customData)
{
    // -- callback used when the command <code>AvailabilityStateChanged</code> of class <code>FlightPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE;
            argDictNewElement->value.U8 = _AvailabilityState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_FlightPlanStateComponentStateListChangedCallback (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component, uint8_t _State, void *customData)
{
    // -- callback used when the command <code>ComponentStateListChanged</code> of class <code>FlightPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _component);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _component);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT;
            argDictNewElement->value.I32 = _component;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE;
            argDictNewElement->value.U8 = _State;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: FlightPlanEvent 
 * FlightPlan Event commands
 */

void ARCONTROLLER_FEATURE_Common_FlightPlanEventStartingErrorEventCallback (void *customData)
{
    // -- callback used when the command <code>StartingErrorEvent</code> of class <code>FlightPlanEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANEVENT_STARTINGERROREVENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_FlightPlanEventSpeedBridleEventCallback (void *customData)
{
    // -- callback used when the command <code>SpeedBridleEvent</code> of class <code>FlightPlanEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANEVENT_SPEEDBRIDLEEVENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: ARLibsVersionsState 
 * ARlibs Versions Commands
 */

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateControllerLibARCommandsVersionCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>ControllerLibARCommandsVersion</code> of class <code>ARLibsVersionsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>SkyControllerLibARCommandsVersion</code> of class <code>ARLibsVersionsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateDeviceLibARCommandsVersionCallback (char * _version, void *customData)
{
    // -- callback used when the command <code>DeviceLibARCommandsVersion</code> of class <code>ARLibsVersionsState is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SetNetworkController (ARCONTROLLER_FEATURE_Common_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_GetCommandElements (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE commonDebug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


const char *ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_STATSEVENT_SENDPACKET_PACKET = "arcontroller_dictionary_key_commondebug_statsevent_sendpacket_packet";

ARCONTROLLER_FEATURE_CommonDebug_t *ARCONTROLLER_FEATURE_CommonDebug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_CommonDebug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_CommonDebug_t));
        if (featureController != NULL)
        {
            featureController->sendStatsSendPacket = ARCONTROLLER_FEATURE_CommonDebug_SendStatsSendPacket;
            featureController->sendStatsStartSendingPacketFromDrone = ARCONTROLLER_FEATURE_CommonDebug_SendStatsStartSendingPacketFromDrone;
            featureController->sendStatsStopSendingPacketFromDrone = ARCONTROLLER_FEATURE_CommonDebug_SendStatsStopSendingPacketFromDrone;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_CommonDebug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_CommonDebug_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_CommonDebug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_CommonDebug_Delete (ARCONTROLLER_FEATURE_CommonDebug_t **feature)
{
    // -- Delete the commonDebug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_CommonDebug_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_CommonDebug_GetDictionary (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the commonDebug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_AddCallback (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>CommonDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_RemoveCallback (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>CommonDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_RegisterARCommands (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : StatsEvent:
        ARCOMMANDS_Decoder_SetCommonDebugStatsEventSendPacketCallback (&ARCONTROLLER_FEATURE_CommonDebug_StatsEventSendPacketCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_UnregisterARCommands (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : StatsEvent:
        ARCOMMANDS_Decoder_SetCommonDebugStatsEventSendPacketCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Stats 
 * Commands to make stats
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendStatsSendPacket (ARCONTROLLER_FEATURE_CommonDebug_t *feature, char * packet)
{
    // -- Send a command <code>SendPacket</code> of class <code>Stats</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SendPacket command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugStatsSendPacket(cmdBuffer, sizeof(cmdBuffer), &cmdSize, packet);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendStatsStartSendingPacketFromDrone (ARCONTROLLER_FEATURE_CommonDebug_t *feature, uint8_t frequency, uint8_t packetSize, uint32_t date)
{
    // -- Send a command <code>StartSendingPacketFromDrone</code> of class <code>Stats</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartSendingPacketFromDrone command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugStatsStartSendingPacketFromDrone(cmdBuffer, sizeof(cmdBuffer), &cmdSize, frequency, packetSize, date);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SendStatsStopSendingPacketFromDrone (ARCONTROLLER_FEATURE_CommonDebug_t *feature)
{
    // -- Send a command <code>StopSendingPacketFromDrone</code> of class <code>Stats</code> in project <code>CommonDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopSendingPacketFromDrone command
        cmdError = ARCOMMANDS_Generator_GenerateCommonDebugStatsStopSendingPacketFromDrone(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: StatsEvent 
 * Stats Event from drone
 */

void ARCONTROLLER_FEATURE_CommonDebug_StatsEventSendPacketCallback (char * _packet, void *customData)
{
    // -- callback used when the command <code>SendPacket</code> of class <code>StatsEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_CommonDebug_t *feature = (ARCONTROLLER_FEATURE_CommonDebug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_STATSEVENT_SENDPACKET;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMONDEBUG_STATSEVENT_SENDPACKET_PACKET;
            strLength = strlen (_packet);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _packet, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_CommonDebug_SetNetworkController (ARCONTROLLER_FEATURE_CommonDebug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_CommonDebug_GetCommandElements (ARCONTROLLER_FEATURE_CommonDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE JumpingSumo --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_posturechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_alertstatechanged_state";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumploadchanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumptypechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumpmotorproblemchanged_error";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_jumpingsumo_settingsstate_productgpsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_jumpingsumo_settingsstate_productgpsversionchanged_hardware";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechangedv2_error";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_pictureeventchanged_error";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_videoeventchanged_error";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_in_or_out";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY = "arcontroller_dictionary_key_jumpingsumo_networkstate_linkqualitychanged_quality";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED_VOLUME = "arcontroller_dictionary_key_jumpingsumo_audiosettingsstate_mastervolumechanged_volume";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME = "arcontroller_dictionary_key_jumpingsumo_audiosettingsstate_themechanged_theme";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_UUID = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_uuid";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_VERSION = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_version";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_PRODUCT = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_product";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_NAME = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_name";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_LASTMODIFIED = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_lastmodified";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptuploadchanged_resultcode";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptdeletechanged_resultcode";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_playscriptchanged_resultcode";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR = "arcontroller_dictionary_key_jumpingsumo_speedsettingsstate_outdoorchanged_outdoor";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_jumpingsumo_mediastreamingstate_videoenablechanged_enabled";

ARCONTROLLER_FEATURE_JumpingSumo_t *ARCONTROLLER_FEATURE_JumpingSumo_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_JumpingSumo_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumo_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDSpeed = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDSpeed;
            featureController->setPilotingPCMDTurn = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDTurn;
            featureController->sendPilotingPosture = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPosture;
            featureController->sendPilotingAddCapOffset = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingAddCapOffset;
            featureController->sendAnimationsJumpStop = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpStop;
            featureController->sendAnimationsJumpCancel = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpCancel;
            featureController->sendAnimationsJumpLoad = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpLoad;
            featureController->sendAnimationsJump = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJump;
            featureController->sendAnimationsSimpleAnimation = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsSimpleAnimation;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPicture;
            featureController->sendMediaRecordVideo = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideo;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideoV2;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkSettingsWifiSelection;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiAuthChannel;
            featureController->sendAudioSettingsMasterVolume = ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsMasterVolume;
            featureController->sendAudioSettingsTheme = ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsTheme;
            featureController->sendRoadPlanAllScriptsMetadata = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanAllScriptsMetadata;
            featureController->sendRoadPlanScriptUploaded = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptUploaded;
            featureController->sendRoadPlanScriptDelete = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptDelete;
            featureController->sendRoadPlanPlayScript = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanPlayScript;
            featureController->sendSpeedSettingsOutdoor = ARCONTROLLER_FEATURE_JumpingSumo_SendSpeedSettingsOutdoor;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaStreamingVideoEnable;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumo_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->pilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->pilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_JumpingSumo_PilotingPCMDParameters_t));
        if (featureController->privatePart == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_JumpingSumo_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_JumpingSumo_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_JumpingSumo_Delete (ARCONTROLLER_FEATURE_JumpingSumo_t **feature)
{
    // -- Delete the JumpingSumo feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_JumpingSumo_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->pilotingPCMDParameters != NULL)
                {
                    free ((*feature)->privatePart->pilotingPCMDParameters);
                    (*feature)->privatePart->pilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_JumpingSumo_GetDictionary (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the JumpingSumo Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_AddCallback (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>JumpingSumo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_RemoveCallback (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>JumpingSumo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_RegisterARCommands (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : PilotingState:
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_PilotingStatePostureChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateAlertStateChangedCallback, feature);
        // Commands of class : AnimationsState:
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpLoadChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpTypeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpMotorProblemChangedCallback, feature);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_SettingsStateProductGPSVersionChangedCallback, feature);
        // Commands of class : MediaRecordState:
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Callback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Callback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedV2Callback, feature);
        // Commands of class : MediaRecordEvent:
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventVideoEventChangedCallback, feature);
        // Commands of class : NetworkSettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        // Commands of class : NetworkState:
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateLinkQualityChangedCallback, feature);
        // Commands of class : AudioSettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateMasterVolumeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateThemeChangedCallback, feature);
        // Commands of class : RoadPlanState:
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptMetadataListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateAllScriptsMetadataChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptUploadChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptDeleteChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStatePlayScriptChangedCallback, feature);
        // Commands of class : SpeedSettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_SpeedSettingsStateOutdoorChangedCallback, feature);
        // Commands of class : MediaStreamingState:
        ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCallback (&ARCONTROLLER_FEATURE_JumpingSumo_MediaStreamingStateVideoEnableChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_UnregisterARCommands (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : PilotingState:
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCallback (NULL, NULL);
        // Commands of class : AnimationsState:
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCallback (NULL, NULL);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCallback (NULL, NULL);
        // Commands of class : MediaRecordState:
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Callback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Callback (NULL, NULL);
        // Commands of class : MediaRecordEvent:
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCallback (NULL, NULL);
        // Commands of class : NetworkSettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (NULL, NULL);
        // Commands of class : NetworkState:
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCallback (NULL, NULL);
        // Commands of class : AudioSettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCallback (NULL, NULL);
        // Commands of class : RoadPlanState:
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCallback (NULL, NULL);
        // Commands of class : SpeedSettingsState:
        ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCallback (NULL, NULL);
        // Commands of class : MediaStreamingState:
        ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Piloting 
 * All commands related to piloting the JumpingSumo
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPCMD (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t flag, int8_t speed, int8_t turn)
{
    // -- Send a command <code>PCMD</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, speed, turn);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMD (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _flag, int8_t _speed, int8_t _turn)
{
    // -- Set the parameter for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->flag = _flag;
        feature->privatePart->pilotingPCMDParameters->speed = _speed;
        feature->privatePart->pilotingPCMDParameters->turn = _turn;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_JumpingSumo_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PCMD</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->pilotingPCMDParameters->flag, feature->privatePart->pilotingPCMDParameters->speed, feature->privatePart->pilotingPCMDParameters->turn);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->flag = _flag;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDSpeed (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _speed)
{
    // -- Set the speed for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->speed = _speed;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDTurn (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _turn)
{
    // -- Set the turn for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->turn = _turn;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPosture (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE type)
{
    // -- Send a command <code>Posture</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Posture command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPosture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingAddCapOffset (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, float offset)
{
    // -- Send a command <code>AddCapOffset</code> of class <code>Piloting</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AddCapOffset command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingAddCapOffset(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: PilotingState 
 * Animations state from JS.
 */

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStatePostureChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PostureChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateAlertStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AlertStateChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Animations 
 * Animation commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpStop (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>JumpStop</code> of class <code>Animations</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpStop command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpCancel (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>JumpCancel</code> of class <code>Animations</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpCancel command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpCancel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpLoad (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>JumpLoad</code> of class <code>Animations</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpLoad command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpLoad(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJump (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE type)
{
    // -- Send a command <code>Jump</code> of class <code>Animations</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Jump command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJump(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsSimpleAnimation (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID id)
{
    // -- Send a command <code>SimpleAnimation</code> of class <code>Animations</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SimpleAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsSimpleAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: AnimationsState 
 * Animations state from JS.
 */

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpLoadChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>JumpLoadChanged</code> of class <code>AnimationsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpTypeChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>JumpTypeChanged</code> of class <code>AnimationsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpMotorProblemChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>JumpMotorProblemChanged</code> of class <code>AnimationsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Settings 
 * Settings commands
 */

/**
 * class: SettingsState 
 * Settings state from product
 */

void ARCONTROLLER_FEATURE_JumpingSumo_SettingsStateProductGPSVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>ProductGPSVersionChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: MediaRecord 
 * Media recording management
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPicture (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>Picture</code> of class <code>MediaRecord</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideo (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD record, uint8_t mass_storage_id)
{
    // -- Send a command <code>Video</code> of class <code>MediaRecord</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>PictureV2</code> of class <code>MediaRecord</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>VideoV2</code> of class <code>MediaRecord</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaRecordState 
 * State of media recording
 */

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>PictureStateChanged</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>VideoStateChanged</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PictureStateChangedV2</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>VideoStateChangedV2</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: MediaRecordEvent 
 * Events of media recording
 */

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PictureEventChanged</code> of class <code>MediaRecordEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>VideoEventChanged</code> of class <code>MediaRecordEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: NetworkSettings 
 * Network settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>WifiSelection</code> of class <code>NetworkSettings</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: NetworkSettingsState 
 * Network settings state from product
 */

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>WifiSelectionChanged</code> of class <code>NetworkSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Network 
 * Network related commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiScan (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>WifiScan</code> of class <code>Network</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>WifiAuthChannel</code> of class <code>Network</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: NetworkState 
 * Network state from Product
 */

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiScanListChangedCallback (char * _ssid, int16_t _rssi, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>WifiScanListChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllWifiScanChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_ALLWIFISCANCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>WifiAuthChannelListChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", HASH_COUNT (dictCmdElement->elements));
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", HASH_COUNT (dictCmdElement->elements));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllWifiAuthChannelChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateLinkQualityChangedCallback (uint8_t _quality, void *customData)
{
    // -- callback used when the command <code>LinkQualityChanged</code> of class <code>NetworkState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY;
            argDictNewElement->value.U8 = _quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: AudioSettings 
 * Audio settings.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsMasterVolume (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t volume)
{
    // -- Send a command <code>MasterVolume</code> of class <code>AudioSettings</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MasterVolume command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAudioSettingsMasterVolume(cmdBuffer, sizeof(cmdBuffer), &cmdSize, volume);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsTheme (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME theme)
{
    // -- Send a command <code>Theme</code> of class <code>AudioSettings</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Theme command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAudioSettingsTheme(cmdBuffer, sizeof(cmdBuffer), &cmdSize, theme);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: AudioSettingsState 
 * Audio settings state.
 */

void ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateMasterVolumeChangedCallback (uint8_t _volume, void *customData)
{
    // -- callback used when the command <code>MasterVolumeChanged</code> of class <code>AudioSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED_VOLUME;
            argDictNewElement->value.U8 = _volume;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateThemeChangedCallback (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme, void *customData)
{
    // -- callback used when the command <code>ThemeChanged</code> of class <code>AudioSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME;
            argDictNewElement->value.I32 = _theme;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: RoadPlan 
 * RoadPlan commands.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanAllScriptsMetadata (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AllScriptsMetadata</code> of class <code>RoadPlan</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllScriptsMetadata command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanAllScriptsMetadata(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptUploaded (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid, char * md5Hash)
{
    // -- Send a command <code>ScriptUploaded</code> of class <code>RoadPlan</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ScriptUploaded command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanScriptUploaded(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid, md5Hash);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptDelete (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid)
{
    // -- Send a command <code>ScriptDelete</code> of class <code>RoadPlan</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ScriptDelete command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanScriptDelete(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanPlayScript (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid)
{
    // -- Send a command <code>PlayScript</code> of class <code>RoadPlan</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PlayScript command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanPlayScript(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: RoadPlanState 
 * RoadPlan command responses.
 */

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptMetadataListChangedCallback (char * _uuid, uint8_t _version, char * _product, char * _name, uint64_t _lastModified, void *customData)
{
    // -- callback used when the command <code>ScriptMetadataListChanged</code> of class <code>RoadPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_uuid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _uuid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_UUID;
            strLength = strlen (_uuid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _uuid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_VERSION;
            argDictNewElement->value.U8 = _version;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_PRODUCT;
            strLength = strlen (_product);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _product, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_LASTMODIFIED;
            argDictNewElement->value.U64 = _lastModified;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateAllScriptsMetadataChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllScriptsMetadataChanged</code> of class <code>RoadPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_ALLSCRIPTSMETADATACHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptUploadChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>ScriptUploadChanged</code> of class <code>RoadPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptDeleteChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>ScriptDeleteChanged</code> of class <code>RoadPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStatePlayScriptChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>PlayScriptChanged</code> of class <code>RoadPlanState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: SpeedSettings 
 * Speed Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendSpeedSettingsOutdoor (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>Outdoor</code> of class <code>SpeedSettings</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Outdoor command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoSpeedSettingsOutdoor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: SpeedSettingsState 
 * Speed Settings state from product
 */

void ARCONTROLLER_FEATURE_JumpingSumo_SpeedSettingsStateOutdoorChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>OutdoorChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: MediaStreaming 
 * Control media streaming behavior.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t enable)
{
    // -- Send a command <code>VideoEnable</code> of class <code>MediaStreaming</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaStreamingState 
 * Media streaming status.
 */

void ARCONTROLLER_FEATURE_JumpingSumo_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>VideoEnableChanged</code> of class <code>MediaStreamingState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetNetworkController (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_GetCommandElements (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE JumpingSumoDebug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/






const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMODEBUG_USERSCRIPTSTATE_USERSCRIPTPARSED_SUCCESS = "arcontroller_dictionary_key_jumpingsumodebug_userscriptstate_userscriptparsed_success";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMODEBUG_USERSCRIPTSTATE_USERSCRIPTPARSED_MESSAGE = "arcontroller_dictionary_key_jumpingsumodebug_userscriptstate_userscriptparsed_message";

ARCONTROLLER_FEATURE_JumpingSumoDebug_t *ARCONTROLLER_FEATURE_JumpingSumoDebug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_JumpingSumoDebug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumoDebug_t));
        if (featureController != NULL)
        {
            featureController->sendJumpSetJumpMotor = ARCONTROLLER_FEATURE_JumpingSumoDebug_SendJumpSetJumpMotor;
            featureController->sendJumpSetCameraOrientation = ARCONTROLLER_FEATURE_JumpingSumoDebug_SendJumpSetCameraOrientation;
            featureController->sendAudioPlaySoundWithName = ARCONTROLLER_FEATURE_JumpingSumoDebug_SendAudioPlaySoundWithName;
            featureController->sendMiscDebugEvent = ARCONTROLLER_FEATURE_JumpingSumoDebug_SendMiscDebugEvent;
			featureController->sendAnimationPlayAnimation =
				/* ARCONTROLLER_FEATURE_JumpingSumoDebug_SendAnimationPlayAnimation */ NULL;
            featureController->sendAnimationAddCapOffset = ARCONTROLLER_FEATURE_JumpingSumoDebug_SendAnimationAddCapOffset;
            featureController->sendUserScriptUserScriptUploaded = ARCONTROLLER_FEATURE_JumpingSumoDebug_SendUserScriptUserScriptUploaded;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumoDebug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_JumpingSumoDebug_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_JumpingSumoDebug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_JumpingSumoDebug_Delete (ARCONTROLLER_FEATURE_JumpingSumoDebug_t **feature)
{
    // -- Delete the JumpingSumoDebug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_JumpingSumoDebug_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_JumpingSumoDebug_GetDictionary (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the JumpingSumoDebug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_AddCallback (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>JumpingSumoDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_RemoveCallback (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>JumpingSumoDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_RegisterARCommands (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : UserScriptState:
        ARCOMMANDS_Decoder_SetJumpingSumoDebugUserScriptStateUserScriptParsedCallback (&ARCONTROLLER_FEATURE_JumpingSumoDebug_UserScriptStateUserScriptParsedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_UnregisterARCommands (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : UserScriptState:
        ARCOMMANDS_Decoder_SetJumpingSumoDebugUserScriptStateUserScriptParsedCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Jump 
 * All debug commands.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendJumpSetJumpMotor (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, int8_t speed)
{
    // -- Send a command <code>SetJumpMotor</code> of class <code>Jump</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetJumpMotor command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugJumpSetJumpMotor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, speed);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendJumpSetCameraOrientation (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, int8_t speedIncrement)
{
    // -- Send a command <code>SetCameraOrientation</code> of class <code>Jump</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetCameraOrientation command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugJumpSetCameraOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, speedIncrement);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: Audio 
 * All audio debug commands.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendAudioPlaySoundWithName (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, char * filename)
{
    // -- Send a command <code>PlaySoundWithName</code> of class <code>Audio</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PlaySoundWithName command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugAudioPlaySoundWithName(cmdBuffer, sizeof(cmdBuffer), &cmdSize, filename);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: Misc 
 * All debug commands that you don't know where ot put.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendMiscDebugEvent (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature)
{
    // -- Send a command <code>DebugEvent</code> of class <code>Misc</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DebugEvent command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugMiscDebugEvent(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: Animation 
 * Triggerable animations.
 */
#if 0
eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendAnimationPlayAnimation (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, eARCOMMANDS_JUMPINGSUMODEBUG_ANIMATION_PLAYANIMATION_ID id)
{
    // -- Send a command <code>PlayAnimation</code> of class <code>Animation</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PlayAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugAnimationPlayAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}
#endif

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendAnimationAddCapOffset (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, float offset)
{
    // -- Send a command <code>AddCapOffset</code> of class <code>Animation</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AddCapOffset command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugAnimationAddCapOffset(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: UserScript 
 * All commands related to user scripts.
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SendUserScriptUserScriptUploaded (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature)
{
    // -- Send a command <code>UserScriptUploaded</code> of class <code>UserScript</code> in project <code>JumpingSumoDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserScriptUploaded command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoDebugUserScriptUserScriptUploaded(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: UserScriptState 
 * All status information related with user scripts.
 */

void ARCONTROLLER_FEATURE_JumpingSumoDebug_UserScriptStateUserScriptParsedCallback (uint8_t _success, char * _message, void *customData)
{
    // -- callback used when the command <code>UserScriptParsed</code> of class <code>UserScriptState is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature = (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMODEBUG_USERSCRIPTSTATE_USERSCRIPTPARSED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMODEBUG_USERSCRIPTSTATE_USERSCRIPTPARSED_SUCCESS;
            argDictNewElement->value.U8 = _success;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMODEBUG_USERSCRIPTSTATE_USERSCRIPTPARSED_MESSAGE;
            strLength = strlen (_message);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _message, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumoDebug_SetNetworkController (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumoDebug_GetCommandElements (ARCONTROLLER_FEATURE_JumpingSumoDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE MiniDrone --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_flyingstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_alertstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_autotakeoffmodechanged_state";



const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_minidrone_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_minidrone_mediarecordevent_pictureeventchanged_error";


const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_max";


const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_max";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED_PRESENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_wheelschanged_present";


const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_MOTOR = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_motor";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_TYPE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_hardware";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productinertialversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productinertialversionchanged_hardware";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED_ENABLE = "arcontroller_dictionary_key_minidrone_settingsstate_cutoutmodechanged_enable";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED_DELAY = "arcontroller_dictionary_key_minidrone_floodcontrolstate_floodcontrolchanged_delay";


ARCONTROLLER_FEATURE_MiniDrone_t *ARCONTROLLER_FEATURE_MiniDrone_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_MiniDrone_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDrone_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingFlatTrim = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlatTrim;
            featureController->sendPilotingTakeOff = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTakeOff;
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDRoll;
            featureController->setPilotingPCMDPitch = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPitch;
            featureController->setPilotingPCMDYaw = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDYaw;
            featureController->setPilotingPCMDGaz = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDGaz;
            featureController->setPilotingPCMDPsi = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPsi;
            featureController->sendPilotingLanding = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingLanding;
            featureController->sendPilotingEmergency = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingEmergency;
            featureController->sendPilotingAutoTakeOffMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingAutoTakeOffMode;
            featureController->sendAnimationsFlip = ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsFlip;
            featureController->sendAnimationsCap = ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsCap;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPicture;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPictureV2;
            featureController->sendPilotingSettingsMaxAltitude = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxAltitude;
            featureController->sendPilotingSettingsMaxTilt = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxTilt;
            featureController->sendSpeedSettingsMaxVerticalSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxVerticalSpeed;
            featureController->sendSpeedSettingsMaxRotationSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxRotationSpeed;
            featureController->sendSpeedSettingsWheels = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsWheels;
            featureController->sendSettingsCutOutMode = ARCONTROLLER_FEATURE_MiniDrone_SendSettingsCutOutMode;
            featureController->sendGPSControllerLatitudeForRun = ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLatitudeForRun;
            featureController->sendGPSControllerLongitudeForRun = ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLongitudeForRun;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDrone_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->pilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->pilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_MiniDrone_PilotingPCMDParameters_t));
        if (featureController->privatePart == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_MiniDrone_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_MiniDrone_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_MiniDrone_Delete (ARCONTROLLER_FEATURE_MiniDrone_t **feature)
{
    // -- Delete the MiniDrone feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_MiniDrone_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->pilotingPCMDParameters != NULL)
                {
                    free ((*feature)->privatePart->pilotingPCMDParameters);
                    (*feature)->privatePart->pilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_MiniDrone_GetDictionary (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the MiniDrone Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_AddCallback (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>MiniDrone</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_RemoveCallback (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>MiniDrone</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_RegisterARCommands (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : PilotingState:
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlatTrimChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAutoTakeOffModeChangedCallback, feature);
        // Commands of class : MediaRecordState:
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Callback (&ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedV2Callback, feature);
        // Commands of class : MediaRecordEvent:
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_MediaRecordEventPictureEventChangedCallback, feature);
        // Commands of class : PilotingSettingsState:
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxTiltChangedCallback, feature);
        // Commands of class : SpeedSettingsState:
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxVerticalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateWheelsChangedCallback, feature);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductMotorsVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductInertialVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_SettingsStateCutOutModeChangedCallback, feature);
        // Commands of class : FloodControlState:
        ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCallback (&ARCONTROLLER_FEATURE_MiniDrone_FloodControlStateFloodControlChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_UnregisterARCommands (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : PilotingState:
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCallback (NULL, NULL);
        // Commands of class : MediaRecordState:
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Callback (NULL, NULL);
        // Commands of class : MediaRecordEvent:
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCallback (NULL, NULL);
        // Commands of class : PilotingSettingsState:
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCallback (NULL, NULL);
        // Commands of class : SpeedSettingsState:
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCallback (NULL, NULL);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCallback (NULL, NULL);
        // Commands of class : FloodControlState:
        ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: Piloting 
 * All commands related to piloting the MiniDrone
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlatTrim (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>FlatTrim</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlatTrim command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingFlatTrim(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTakeOff (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>TakeOff</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPCMD (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t flag, int8_t roll, int8_t pitch, int8_t yaw, int8_t gaz, float psi)
{
    // -- Send a command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, roll, pitch, yaw, gaz, psi);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMD (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _flag, int8_t _roll, int8_t _pitch, int8_t _yaw, int8_t _gaz, float _psi)
{
    // -- Set the parameter for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->flag = _flag;
        feature->privatePart->pilotingPCMDParameters->roll = _roll;
        feature->privatePart->pilotingPCMDParameters->pitch = _pitch;
        feature->privatePart->pilotingPCMDParameters->yaw = _yaw;
        feature->privatePart->pilotingPCMDParameters->gaz = _gaz;
        feature->privatePart->pilotingPCMDParameters->psi = _psi;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_MiniDrone_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->pilotingPCMDParameters->flag, feature->privatePart->pilotingPCMDParameters->roll, feature->privatePart->pilotingPCMDParameters->pitch, feature->privatePart->pilotingPCMDParameters->yaw, feature->privatePart->pilotingPCMDParameters->gaz, feature->privatePart->pilotingPCMDParameters->psi);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->flag = _flag;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->roll = _roll;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPitch (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _pitch)
{
    // -- Set the pitch for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->pitch = _pitch;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDYaw (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _yaw)
{
    // -- Set the yaw for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->yaw = _yaw;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDGaz (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _gaz)
{
    // -- Set the gaz for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->gaz = _gaz;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPsi (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _psi)
{
    // -- Set the psi for the command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->pilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->pilotingPCMDParameters->psi = _psi;
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingLanding (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>Landing</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Landing command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingLanding(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingEmergency (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>Emergency</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Emergency command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingEmergency(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingAutoTakeOffMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t state)
{
    // -- Send a command <code>AutoTakeOffMode</code> of class <code>Piloting</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoTakeOffMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingAutoTakeOffMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: PilotingState 
 * Occasional information
 */

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlatTrimChangedCallback (void *customData)
{
    // -- callback used when the command <code>FlatTrimChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLATTRIMCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>FlyingStateChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAlertStateChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AlertStateChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAutoTakeOffModeChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>AutoTakeOffModeChanged</code> of class <code>PilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Animations 
 * Animation commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsFlip (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION direction)
{
    // -- Send a command <code>Flip</code> of class <code>Animations</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Flip command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneAnimationsFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsCap (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int16_t offset)
{
    // -- Send a command <code>Cap</code> of class <code>Animations</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Cap command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneAnimationsCap(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaRecord 
 * Media recording management
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPicture (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>Picture</code> of class <code>MediaRecord</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PictureV2</code> of class <code>MediaRecord</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: MediaRecordState 
 * State of media recording
 */

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>PictureStateChanged</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PictureStateChangedV2</code> of class <code>MediaRecordState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: MediaRecordEvent 
 * Events of media recording
 */

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PictureEventChanged</code> of class <code>MediaRecordEvent is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: PilotingSettings 
 * Piloting Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxAltitude (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>MaxAltitude</code> of class <code>PilotingSettings</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxTilt (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>MaxTilt</code> of class <code>PilotingSettings</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxTilt command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxTilt(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: PilotingSettingsState 
 * Piloting Settings state from product
 */

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxAltitudeChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxTiltChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxTiltChanged</code> of class <code>PilotingSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: SpeedSettings 
 * Speed Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxVerticalSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>MaxVerticalSpeed</code> of class <code>SpeedSettings</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxRotationSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>MaxRotationSpeed</code> of class <code>SpeedSettings</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsWheels (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t present)
{
    // -- Send a command <code>Wheels</code> of class <code>SpeedSettings</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Wheels command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsWheels(cmdBuffer, sizeof(cmdBuffer), &cmdSize, present);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: SpeedSettingsState 
 * Speed Settings state from product
 */

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxVerticalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxVerticalSpeedChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>MaxRotationSpeedChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateWheelsChangedCallback (uint8_t _present, void *customData)
{
    // -- callback used when the command <code>WheelsChanged</code> of class <code>SpeedSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED_PRESENT;
            argDictNewElement->value.U8 = _present;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Settings 
 * Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSettingsCutOutMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t enable)
{
    // -- Send a command <code>CutOutMode</code> of class <code>Settings</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CutOutMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSettingsCutOutMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: SettingsState 
 * Settings state from product
 */

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductMotorsVersionChangedCallback (uint8_t _motor, char * _type, char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>ProductMotorsVersionChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_MOTOR;
            argDictNewElement->value.U8 = _motor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_TYPE;
            strLength = strlen (_type);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _type, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductInertialVersionChangedCallback (char * _software, char * _hardware, void *customData)
{
    // -- callback used when the command <code>ProductInertialVersionChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateCutOutModeChangedCallback (uint8_t _enable, void *customData)
{
    // -- callback used when the command <code>CutOutModeChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED_ENABLE;
            argDictNewElement->value.U8 = _enable;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: FloodControlState 
 * Settings state from product
 */

void ARCONTROLLER_FEATURE_MiniDrone_FloodControlStateFloodControlChangedCallback (uint16_t _delay, void *customData)
{
    // -- callback used when the command <code>FloodControlChanged</code> of class <code>FloodControlState is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED_DELAY;
            argDictNewElement->value.U16 = _delay;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: GPS 
 * GPS related commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLatitudeForRun (ARCONTROLLER_FEATURE_MiniDrone_t *feature, double latitude)
{
    // -- Send a command <code>ControllerLatitudeForRun</code> of class <code>GPS</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerLatitudeForRun command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneGPSControllerLatitudeForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLongitudeForRun (ARCONTROLLER_FEATURE_MiniDrone_t *feature, double longitude)
{
    // -- Send a command <code>ControllerLongitudeForRun</code> of class <code>GPS</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerLongitudeForRun command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneGPSControllerLongitudeForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, longitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetNetworkController (ARCONTROLLER_FEATURE_MiniDrone_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_GetCommandElements (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE MiniDroneDebug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


ARCONTROLLER_FEATURE_MiniDroneDebug_t *ARCONTROLLER_FEATURE_MiniDroneDebug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_MiniDroneDebug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDroneDebug_t));
        if (featureController != NULL)
        {
            featureController->sendDebugTest1 = ARCONTROLLER_FEATURE_MiniDroneDebug_SendDebugTest1;
            featureController->sendDebugTest2 = ARCONTROLLER_FEATURE_MiniDroneDebug_SendDebugTest2;
            featureController->sendDebugTest3 = ARCONTROLLER_FEATURE_MiniDroneDebug_SendDebugTest3;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDroneDebug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_MiniDroneDebug_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_MiniDroneDebug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_MiniDroneDebug_Delete (ARCONTROLLER_FEATURE_MiniDroneDebug_t **feature)
{
    // -- Delete the MiniDroneDebug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_MiniDroneDebug_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_MiniDroneDebug_GetDictionary (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the MiniDroneDebug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_AddCallback (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>MiniDroneDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_RemoveCallback (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>MiniDroneDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_RegisterARCommands (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_UnregisterARCommands (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

/**
 * class: Debug 
 * Temporary, debug commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_SendDebugTest1 (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, int8_t t1Args)
{
    // -- Send a command <code>Test1</code> of class <code>Debug</code> in project <code>MiniDroneDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Test1 command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneDebugDebugTest1(cmdBuffer, sizeof(cmdBuffer), &cmdSize, t1Args);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_SendDebugTest2 (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, int8_t t2Args)
{
    // -- Send a command <code>Test2</code> of class <code>Debug</code> in project <code>MiniDroneDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Test2 command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneDebugDebugTest2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, t2Args);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_SendDebugTest3 (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, int8_t t3Args)
{
    // -- Send a command <code>Test3</code> of class <code>Debug</code> in project <code>MiniDroneDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Test3 command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneDebugDebugTest3(cmdBuffer, sizeof(cmdBuffer), &cmdSize, t3Args);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDroneDebug_SetNetworkController (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDroneDebug_GetCommandElements (ARCONTROLLER_FEATURE_MiniDroneDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE SkyController --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_BSSID = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_bssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SSID = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SECURED = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_secured";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SAVED = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_saved";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_RSSI = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_FREQUENCY = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_frequency";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_SSID = "arcontroller_dictionary_key_skycontroller_wifistate_connexionchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS = "arcontroller_dictionary_key_skycontroller_wifistate_connexionchanged_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_in_or_out";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED_LEVEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifisignalchanged_level";



const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST_NAME = "arcontroller_dictionary_key_skycontroller_devicestate_devicelist_name";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICENAME = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_devicename";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICEPRODUCTID = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_deviceproductid";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED_SERIALNUMBER = "arcontroller_dictionary_key_skycontroller_settingsstate_productserialchanged_serialnumber";



const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED_PERCENT = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_batterychanged_percent";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED_FIXED = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpsfixchanged_fixed";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LATITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_HEADING = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_heading";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED_SSID = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_accesspointssidchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_accesspointchannelchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_channel";



const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_ID = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_NAME = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_KEY_ID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_currentbuttonmappings_key_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_currentbuttonmappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_availablebuttonmappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_NAME = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_availablebuttonmappings_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_AXIS_ID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_currentaxismappings_axis_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_currentaxismappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_availableaxismappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_NAME = "arcontroller_dictionary_key_skycontroller_axismappingsstate_availableaxismappings_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_AXIS_ID = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_currentaxisfilters_axis_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_FILTER_UID_OR_BUILDER = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_currentaxisfilters_filter_uid_or_builder";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_FILTER_UID = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_presetaxisfilters_filter_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_NAME = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_presetaxisfilters_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE = "arcontroller_dictionary_key_skycontroller_copilotingstate_pilotingsource_source";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_X_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_x_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Y_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_y_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Z_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_z_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE_ENABLED = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationqualityupdatesstate_enabled";

ARCONTROLLER_FEATURE_SkyController_t *ARCONTROLLER_FEATURE_SkyController_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_SkyController_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_SkyController_t));
        if (featureController != NULL)
        {
            featureController->sendWifiRequestWifiList = ARCONTROLLER_FEATURE_SkyController_SendWifiRequestWifiList;
            featureController->sendWifiRequestCurrentWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiRequestCurrentWifi;
            featureController->sendWifiConnectToWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiConnectToWifi;
            featureController->sendWifiForgetWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiForgetWifi;
            featureController->sendWifiWifiAuthChannel = ARCONTROLLER_FEATURE_SkyController_SendWifiWifiAuthChannel;
            featureController->sendDeviceRequestDeviceList = ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestDeviceList;
            featureController->sendDeviceRequestCurrentDevice = ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestCurrentDevice;
            featureController->sendDeviceConnectToDevice = ARCONTROLLER_FEATURE_SkyController_SendDeviceConnectToDevice;
            featureController->sendSettingsAllSettings = ARCONTROLLER_FEATURE_SkyController_SendSettingsAllSettings;
            featureController->sendSettingsReset = ARCONTROLLER_FEATURE_SkyController_SendSettingsReset;
            featureController->sendCommonAllStates = ARCONTROLLER_FEATURE_SkyController_SendCommonAllStates;
            featureController->sendAccessPointSettingsAccessPointSSID = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointSSID;
            featureController->sendAccessPointSettingsAccessPointChannel = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointChannel;
            featureController->sendAccessPointSettingsWifiSelection = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSelection;
            featureController->sendCameraResetOrientation = ARCONTROLLER_FEATURE_SkyController_SendCameraResetOrientation;
            featureController->sendGamepadInfosGetGamepadControls = ARCONTROLLER_FEATURE_SkyController_SendGamepadInfosGetGamepadControls;
            featureController->sendButtonMappingsGetCurrentButtonMappings = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetCurrentButtonMappings;
            featureController->sendButtonMappingsGetAvailableButtonMappings = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetAvailableButtonMappings;
            featureController->sendButtonMappingsSetButtonMapping = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsSetButtonMapping;
            featureController->sendButtonMappingsDefaultButtonMapping = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsDefaultButtonMapping;
            featureController->sendAxisMappingsGetCurrentAxisMappings = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetCurrentAxisMappings;
            featureController->sendAxisMappingsGetAvailableAxisMappings = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetAvailableAxisMappings;
            featureController->sendAxisMappingsSetAxisMapping = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsSetAxisMapping;
            featureController->sendAxisMappingsDefaultAxisMapping = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsDefaultAxisMapping;
            featureController->sendAxisFiltersGetCurrentAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetCurrentAxisFilters;
            featureController->sendAxisFiltersGetPresetAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetPresetAxisFilters;
            featureController->sendAxisFiltersSetAxisFilter = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersSetAxisFilter;
            featureController->sendAxisFiltersDefaultAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersDefaultAxisFilters;
            featureController->sendCoPilotingSetPilotingSource = ARCONTROLLER_FEATURE_SkyController_SendCoPilotingSetPilotingSource;
            featureController->sendCalibrationEnableMagnetoCalibrationQualityUpdates = ARCONTROLLER_FEATURE_SkyController_SendCalibrationEnableMagnetoCalibrationQualityUpdates;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_SkyController_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_SkyController_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_SkyController_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_SkyController_Delete (ARCONTROLLER_FEATURE_SkyController_t **feature)
{
    // -- Delete the SkyController feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_SkyController_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_SkyController_GetDictionary (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the SkyController Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_AddCallback (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>SkyController</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_RemoveCallback (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>SkyController</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_RegisterARCommands (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : WifiState:
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateWifiListCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateConnexionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCallback (&ARCONTROLLER_FEATURE_SkyController_WifiStateWifiSignalChangedCallback, feature);
        // Commands of class : DeviceState:
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCallback (&ARCONTROLLER_FEATURE_SkyController_DeviceStateDeviceListCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_DeviceStateConnexionChangedCallback, feature);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateAllSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateResetChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SettingsStateProductSerialChangedCallback, feature);
        // Commands of class : CommonState:
        ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCallback (&ARCONTROLLER_FEATURE_SkyController_CommonStateAllStatesChangedCallback, feature);
        // Commands of class : SkyControllerState:
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsFixChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsPositionChangedCallback, feature);
        // Commands of class : AccessPointSettingsState:
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (&ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointSSIDChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (&ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (&ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSelectionChangedCallback, feature);
        // Commands of class : GamepadInfosState:
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCallback (&ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateGamepadControlCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCallback (&ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateAllGamepadControlsSentCallback, feature);
        // Commands of class : ButtonMappingsState:
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateCurrentButtonMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllCurrentButtonMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAvailableButtonMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllAvailableButtonsMappingsSentCallback, feature);
        // Commands of class : AxisMappingsState:
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateCurrentAxisMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllCurrentAxisMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAvailableAxisMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllAvailableAxisMappingsSentCallback, feature);
        // Commands of class : AxisFiltersState:
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateCurrentAxisFiltersCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllCurrentFiltersSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStatePresetAxisFiltersCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCallback (&ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllPresetFiltersSentCallback, feature);
        // Commands of class : CoPilotingState:
        ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCallback (&ARCONTROLLER_FEATURE_SkyController_CoPilotingStatePilotingSourceCallback, feature);
        // Commands of class : CalibrationState:
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCallback (&ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (&ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationQualityUpdatesStateCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_UnregisterARCommands (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Commands of class : WifiState:
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCallback (NULL, NULL);
        // Commands of class : DeviceState:
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCallback (NULL, NULL);
        // Commands of class : SettingsState:
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCallback (NULL, NULL);
        // Commands of class : CommonState:
        ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCallback (NULL, NULL);
        // Commands of class : SkyControllerState:
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCallback (NULL, NULL);
        // Commands of class : AccessPointSettingsState:
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (NULL, NULL);
        // Commands of class : GamepadInfosState:
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCallback (NULL, NULL);
        // Commands of class : ButtonMappingsState:
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (NULL, NULL);
        // Commands of class : AxisMappingsState:
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (NULL, NULL);
        // Commands of class : AxisFiltersState:
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCallback (NULL, NULL);
        // Commands of class : CoPilotingState:
        ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCallback (NULL, NULL);
        // Commands of class : CalibrationState:
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCallback (NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (NULL, NULL);
    }
    
    return error;
}

/**
 * class: WifiState 
 * Wifi state
 */

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiListCallback (char * _bssid, char * _ssid, uint8_t _secured, uint8_t _saved, int32_t _rssi, int32_t _frequency, void *customData)
{
    // -- callback used when the command <code>WifiList</code> of class <code>WifiState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_bssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _bssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_BSSID;
            strLength = strlen (_bssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _bssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SECURED;
            argDictNewElement->value.U8 = _secured;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SAVED;
            argDictNewElement->value.U8 = _saved;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_RSSI;
            argDictNewElement->value.I32 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateConnexionChangedCallback (char * _ssid, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status, void *customData)
{
    // -- callback used when the command <code>ConnexionChanged</code> of class <code>WifiState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedCallback (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>WifiAuthChannelListChanged</code> of class <code>WifiState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", HASH_COUNT (dictCmdElement->elements));
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", HASH_COUNT (dictCmdElement->elements));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllWifiAuthChannelChanged</code> of class <code>WifiState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_ALLWIFIAUTHCHANNELCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiSignalChangedCallback (uint8_t _level, void *customData)
{
    // -- callback used when the command <code>WifiSignalChanged</code> of class <code>WifiState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED_LEVEL;
            argDictNewElement->value.U8 = _level;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Wifi 
 * Wifi
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiRequestWifiList (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>RequestWifiList</code> of class <code>Wifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestWifiList command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiRequestWifiList(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiRequestCurrentWifi (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>RequestCurrentWifi</code> of class <code>Wifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestCurrentWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiRequestCurrentWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiConnectToWifi (ARCONTROLLER_FEATURE_SkyController_t *feature, char * bssid, char * ssid, char * passphrase)
{
    // -- Send a command <code>ConnectToWifi</code> of class <code>Wifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConnectToWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiConnectToWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize, bssid, ssid, passphrase);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiForgetWifi (ARCONTROLLER_FEATURE_SkyController_t *feature, char * ssid)
{
    // -- Send a command <code>ForgetWifi</code> of class <code>Wifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ForgetWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiForgetWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ssid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiWifiAuthChannel (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiAuthChannel</code> of class <code>Wifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: Device 
 * Device Connection commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestDeviceList (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>RequestDeviceList</code> of class <code>Device</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestDeviceList command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceRequestDeviceList(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestCurrentDevice (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>RequestCurrentDevice</code> of class <code>Device</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestCurrentDevice command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceRequestCurrentDevice(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceConnectToDevice (ARCONTROLLER_FEATURE_SkyController_t *feature, char * deviceName)
{
    // -- Send a command <code>ConnectToDevice</code> of class <code>Device</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConnectToDevice command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceConnectToDevice(cmdBuffer, sizeof(cmdBuffer), &cmdSize, deviceName);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: DeviceState 
 * Device state
 */

void ARCONTROLLER_FEATURE_SkyController_DeviceStateDeviceListCallback (char * _name, void *customData)
{
    // -- callback used when the command <code>DeviceList</code> of class <code>DeviceState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", HASH_COUNT (dictCmdElement->elements));
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", HASH_COUNT (dictCmdElement->elements));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_DeviceStateConnexionChangedCallback (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status, char * _deviceName, uint16_t _deviceProductID, void *customData)
{
    // -- callback used when the command <code>ConnexionChanged</code> of class <code>DeviceState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICENAME;
            strLength = strlen (_deviceName);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _deviceName, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICEPRODUCTID;
            argDictNewElement->value.U16 = _deviceProductID;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Settings 
 * Settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendSettingsAllSettings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AllSettings</code> of class <code>Settings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerSettingsAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendSettingsReset (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>Reset</code> of class <code>Settings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerSettingsReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: SettingsState 
 * Settings state from product
 */

void ARCONTROLLER_FEATURE_SkyController_SettingsStateAllSettingsChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllSettingsChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_ALLSETTINGSCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateResetChangedCallback (void *customData)
{
    // -- callback used when the command <code>ResetChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_RESETCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateProductSerialChangedCallback (char * _serialNumber, void *customData)
{
    // -- callback used when the command <code>ProductSerialChanged</code> of class <code>SettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED_SERIALNUMBER;
            strLength = strlen (_serialNumber);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serialNumber, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Common 
 * Common commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCommonAllStates (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AllStates</code> of class <code>Common</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllStates command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCommonAllStates(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

/**
 * class: CommonState 
 * Common state from product
 */

void ARCONTROLLER_FEATURE_SkyController_CommonStateAllStatesChangedCallback (void *customData)
{
    // -- callback used when the command <code>AllStatesChanged</code> of class <code>CommonState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COMMONSTATE_ALLSTATESCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: SkyControllerState 
 * Sky Controller states
 */

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryChangedCallback (uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>BatteryChanged</code> of class <code>SkyControllerState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsFixChangedCallback (uint8_t _fixed, void *customData)
{
    // -- callback used when the command <code>GpsFixChanged</code> of class <code>SkyControllerState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED_FIXED;
            argDictNewElement->value.U8 = _fixed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsPositionChangedCallback (double _latitude, double _longitude, double _altitude, float _heading, void *customData)
{
    // -- callback used when the command <code>GpsPositionChanged</code> of class <code>SkyControllerState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_HEADING;
            argDictNewElement->value.Float = _heading;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: AccessPointSettings 
 * AccessPoint settings commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointSSID (ARCONTROLLER_FEATURE_SkyController_t *feature, char * ssid)
{
    // -- Send a command <code>AccessPointSSID</code> of class <code>AccessPointSettings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AccessPointSSID command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsAccessPointSSID(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ssid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointChannel (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t channel)
{
    // -- Send a command <code>AccessPointChannel</code> of class <code>AccessPointSettings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AccessPointChannel command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsAccessPointChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSelection (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>WifiSelection</code> of class <code>AccessPointSettings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: AccessPointSettingsState 
 * AccessPoint settings state from product
 */

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointSSIDChangedCallback (char * _ssid, void *customData)
{
    // -- callback used when the command <code>AccessPointSSIDChanged</code> of class <code>AccessPointSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointChannelChangedCallback (uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>AccessPointChannelChanged</code> of class <code>AccessPointSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>WifiSelectionChanged</code> of class <code>AccessPointSettingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Camera 
 * Ask the drone to move camera
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCameraResetOrientation (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ResetOrientation</code> of class <code>Camera</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetOrientation command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCameraResetOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: GamepadInfos 
 * Request infos about the gamepad of the SkyController
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendGamepadInfosGetGamepadControls (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetGamepadControls</code> of class <code>GamepadInfos</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetGamepadControls command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerGamepadInfosGetGamepadControls(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: GamepadInfosState 
 * Informations about the gamepad of the SkyController
 */

void ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateGamepadControlCallback (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type, int32_t _id, char * _name, void *customData)
{
    // -- callback used when the command <code>GamepadControl</code> of class <code>GamepadInfosState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", HASH_COUNT (dictCmdElement->elements));
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", HASH_COUNT (dictCmdElement->elements));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_ID;
            argDictNewElement->value.I32 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateAllGamepadControlsSentCallback (void *customData)
{
    // -- callback used when the command <code>AllGamepadControlsSent</code> of class <code>GamepadInfosState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_ALLGAMEPADCONTROLSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: ButtonMappings 
 * Controls the button mappings of the SkyController
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetCurrentButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetCurrentButtonMappings</code> of class <code>ButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentButtonMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsGetCurrentButtonMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetAvailableButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetAvailableButtonMappings</code> of class <code>ButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAvailableButtonMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsGetAvailableButtonMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsSetButtonMapping (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t key_id, char * mapping_uid)
{
    // -- Send a command <code>SetButtonMapping</code> of class <code>ButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetButtonMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsSetButtonMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, key_id, mapping_uid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsDefaultButtonMapping (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DefaultButtonMapping</code> of class <code>ButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultButtonMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsDefaultButtonMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: ButtonMappingsState 
 * State of the button mappings of the SkyController
 */

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateCurrentButtonMappingsCallback (int32_t _key_id, char * _mapping_uid, void *customData)
{
    // -- callback used when the command <code>CurrentButtonMappings</code> of class <code>ButtonMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _key_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _key_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_KEY_ID;
            argDictNewElement->value.I32 = _key_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllCurrentButtonMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AllCurrentButtonMappingsSent</code> of class <code>ButtonMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_ALLCURRENTBUTTONMAPPINGSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAvailableButtonMappingsCallback (char * _mapping_uid, char * _name, void *customData)
{
    // -- callback used when the command <code>AvailableButtonMappings</code> of class <code>ButtonMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_mapping_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _mapping_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllAvailableButtonsMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AllAvailableButtonsMappingsSent</code> of class <code>ButtonMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_ALLAVAILABLEBUTTONSMAPPINGSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: AxisMappings 
 * Controls the axis mappings of the SkyController
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetCurrentAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetCurrentAxisMappings</code> of class <code>AxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentAxisMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsGetCurrentAxisMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetAvailableAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetAvailableAxisMappings</code> of class <code>AxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAvailableAxisMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsGetAvailableAxisMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsSetAxisMapping (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t axis_id, char * mapping_uid)
{
    // -- Send a command <code>SetAxisMapping</code> of class <code>AxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAxisMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsSetAxisMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, axis_id, mapping_uid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsDefaultAxisMapping (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DefaultAxisMapping</code> of class <code>AxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultAxisMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsDefaultAxisMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: AxisMappingsState 
 * State of the axis mappings of the SkyController
 */

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateCurrentAxisMappingsCallback (int32_t _axis_id, char * _mapping_uid, void *customData)
{
    // -- callback used when the command <code>CurrentAxisMappings</code> of class <code>AxisMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _axis_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _axis_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_AXIS_ID;
            argDictNewElement->value.I32 = _axis_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllCurrentAxisMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AllCurrentAxisMappingsSent</code> of class <code>AxisMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_ALLCURRENTAXISMAPPINGSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAvailableAxisMappingsCallback (char * _mapping_uid, char * _name, void *customData)
{
    // -- callback used when the command <code>AvailableAxisMappings</code> of class <code>AxisMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_mapping_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _mapping_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllAvailableAxisMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AllAvailableAxisMappingsSent</code> of class <code>AxisMappingsState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_ALLAVAILABLEAXISMAPPINGSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: AxisFilters 
 * Controls the axis filters of the SkyController
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetCurrentAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetCurrentAxisFilters</code> of class <code>AxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersGetCurrentAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetPresetAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GetPresetAxisFilters</code> of class <code>AxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetPresetAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersGetPresetAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersSetAxisFilter (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t axis_id, char * filter_uid_or_builder)
{
    // -- Send a command <code>SetAxisFilter</code> of class <code>AxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAxisFilter command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersSetAxisFilter(cmdBuffer, sizeof(cmdBuffer), &cmdSize, axis_id, filter_uid_or_builder);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersDefaultAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DefaultAxisFilters</code> of class <code>AxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersDefaultAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: AxisFiltersState 
 * State of the axis filters of the SkyController
 */

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateCurrentAxisFiltersCallback (int32_t _axis_id, char * _filter_uid_or_builder, void *customData)
{
    // -- callback used when the command <code>CurrentAxisFilters</code> of class <code>AxisFiltersState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _axis_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _axis_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_AXIS_ID;
            argDictNewElement->value.I32 = _axis_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_FILTER_UID_OR_BUILDER;
            strLength = strlen (_filter_uid_or_builder);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filter_uid_or_builder, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllCurrentFiltersSentCallback (void *customData)
{
    // -- callback used when the command <code>AllCurrentFiltersSent</code> of class <code>AxisFiltersState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_ALLCURRENTFILTERSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStatePresetAxisFiltersCallback (char * _filter_uid, char * _name, void *customData)
{
    // -- callback used when the command <code>PresetAxisFilters</code> of class <code>AxisFiltersState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_filter_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _filter_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_FILTER_UID;
            strLength = strlen (_filter_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filter_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (error == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    if (newElement->arguments->value.String != NULL)
                    {
                        free(newElement->arguments->value.String);
                        newElement->arguments->value.String = NULL;
                    }
                    
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllPresetFiltersSentCallback (void *customData)
{
    // -- callback used when the command <code>AllPresetFiltersSent</code> of class <code>AxisFiltersState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_ALLPRESETFILTERSSENT;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: CoPiloting 
 * Configuration of the co-piloting feature
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCoPilotingSetPilotingSource (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE source)
{
    // -- Send a command <code>SetPilotingSource</code> of class <code>CoPiloting</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetPilotingSource command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCoPilotingSetPilotingSource(cmdBuffer, sizeof(cmdBuffer), &cmdSize, source);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: CoPilotingState 
 * State of the co-piloting feature
 */

void ARCONTROLLER_FEATURE_SkyController_CoPilotingStatePilotingSourceCallback (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source, void *customData)
{
    // -- callback used when the command <code>PilotingSource</code> of class <code>CoPilotingState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE;
            argDictNewElement->value.I32 = _source;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

/**
 * class: Calibration 
 * Commands related to the SkyController sensors calibration
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCalibrationEnableMagnetoCalibrationQualityUpdates (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t enable)
{
    // -- Send a command <code>EnableMagnetoCalibrationQualityUpdates</code> of class <code>Calibration</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send EnableMagnetoCalibrationQualityUpdates command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCalibrationEnableMagnetoCalibrationQualityUpdates(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

/**
 * class: CalibrationState 
 * State of the SkyController calibration
 */

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateCallback (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status, uint8_t _X_Quality, uint8_t _Y_Quality, uint8_t _Z_Quality, void *customData)
{
    // -- callback used when the command <code>MagnetoCalibrationState</code> of class <code>CalibrationState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_X_QUALITY;
            argDictNewElement->value.U8 = _X_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Y_QUALITY;
            argDictNewElement->value.U8 = _Y_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Z_QUALITY;
            argDictNewElement->value.U8 = _Z_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>MagnetoCalibrationQualityUpdatesState</code> of class <code>CalibrationState is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE;
    int elementAdded = 0;
    int isANewCommandElement = 0;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find command elements
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
            if (dictCmdElement != NULL)
            {
                dictCmdElement->command = commandKey;
                dictCmdElement->elements = NULL;
            }
            else
            {
                error = ARCONTROLLER_ERROR_ALLOC;
            }
        }
        // No Else ; commandElement already exists.
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create Element Dictionary
    if (error == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (error == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            error = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find if the element already exist
        HASH_FIND_STR (dictCmdElement->elements, newElement->key, oldElement);
        if (oldElement != NULL)
        {
            HASH_REPLACE_STR (dictCmdElement->elements, key, newElement, oldElement);
            
            ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
            free (oldElement);
            oldElement = NULL;
        }
        else
        {
            HASH_ADD_KEYPTR (hh, dictCmdElement->elements, newElement->key, strlen(newElement->key), newElement);
        }
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Callback notification
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (!elementAdded ))
        {
            if (newElement != NULL)
            {
                if (newElement->arguments != NULL)
                {
                    free (newElement->arguments);
                    newElement->arguments = NULL;
                }
                
                if (newElement->key != NULL)
                {
                    free (newElement->key);
                    newElement->key = NULL;
                }
                
                free (newElement);
                newElement = NULL;
            }
            if (isANewCommandElement)
            {
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
        }
    }
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SetNetworkController (ARCONTROLLER_FEATURE_SkyController_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_GetCommandElements (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE SkyControllerDebug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


ARCONTROLLER_FEATURE_SkyControllerDebug_t *ARCONTROLLER_FEATURE_SkyControllerDebug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_SkyControllerDebug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_SkyControllerDebug_t));
        if (featureController != NULL)
        {
            featureController->sendDebugTest1 = ARCONTROLLER_FEATURE_SkyControllerDebug_SendDebugTest1;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_SkyControllerDebug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_FEATURE_SkyControllerDebug_RegisterARCommands (featureController);
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_SkyControllerDebug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_SkyControllerDebug_Delete (ARCONTROLLER_FEATURE_SkyControllerDebug_t **feature)
{
    // -- Delete the SkyControllerDebug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            ARCONTROLLER_FEATURE_SkyControllerDebug_UnregisterARCommands ((*feature));
            
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_SkyControllerDebug_GetDictionary (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the SkyControllerDebug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyControllerDebug_AddCallback (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>SkyControllerDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyControllerDebug_RemoveCallback (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>SkyControllerDebug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyControllerDebug_RegisterARCommands (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyControllerDebug_UnregisterARCommands (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

/**
 * class: Debug 
 * Temporary, debug commands
 */

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyControllerDebug_SendDebugTest1 (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature, int8_t t1Args)
{
    // -- Send a command <code>Test1</code> of class <code>Debug</code> in project <code>SkyControllerDebug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    uint8_t cmdBuffer[128];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Test1 command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDebugDebugTest1(cmdBuffer, sizeof(cmdBuffer), &cmdSize, t1Args);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyControllerDebug_SetNetworkController (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyControllerDebug_GetCommandElements (ARCONTROLLER_FEATURE_SkyControllerDebug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/

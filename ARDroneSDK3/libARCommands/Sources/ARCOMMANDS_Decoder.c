/*
    Copyright (C) 2014 Parrot SA
    
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.
    * Neither the name of Parrot nor the names
    of its contributors may be used to endorse or promote products
    derived from this software without specific prior written
    permission.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/
/********************************************
 *            AUTOGENERATED FILE            *
 *             DO NOT MODIFY IT             *
 *                                          *
 * To add new commands :                    *
 *  - Modify ../Xml/commands.xml file       *
 *  - Re-run generateCommandsList.py script *
 *                                          *
 ********************************************/
#include <config.h>
#include <stdio.h>
#include "ARCOMMANDS_ReadWrite.h"
#include "libARCommands/ARCOMMANDS_Types.h"
#include "libARCommands/ARCOMMANDS_Decoder.h"
#include "ARCOMMANDS_Ids.h"
#include <libARSAL/ARSAL_Mutex.h>

// CALLBACK VARIABLES + SETTERS

static ARSAL_Mutex_t ARCOMMANDS_Decoder_Mutex;
static int ARCOMMANDS_Decoder_IsInit = 0;
int ARCOMMANDS_Decoder_Init (void)
{
    if ((ARCOMMANDS_Decoder_IsInit == 0) &&
        (ARSAL_Mutex_Init (&ARCOMMANDS_Decoder_Mutex) == 0))
    {
        ARCOMMANDS_Decoder_IsInit = 1;
    } // No else --> Do nothing if already initialized
    return ARCOMMANDS_Decoder_IsInit;
}

// Project ARDrone3

// Command class Piloting
static ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingFlatTrimCallback (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingTakeOffCallback (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingPCMDCallback (ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingLandingCallback (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingEmergencyCallback (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingNavigateHomeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingAutoTakeOffModeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Animations
static ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AnimationsFlipCallback (ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Camera
static ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecord
static ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecordState
static ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecordEvent
static ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingState
static ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Network
static ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiScanCallback (ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkState
static ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingSettings
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxTiltCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsAbsolutControlCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxDistanceCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingSettingsState
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SpeedSettings
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsHullProtectionCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsOutdoorCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SpeedSettingsState
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkSettings
static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkSettingsState
static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Settings

// Command class SettingsState
static ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class DirectorMode

// Command class DirectorModeState

// Command class PictureSettings
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsPictureFormatSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsExpositionSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsSaturationSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsTimelapseSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoAutorecordSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PictureSettingsState
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaStreaming
static ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaStreamingState
static ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GPSSettings
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSetHomeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsResetHomeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSendControllerGPSCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsHomeTypeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsReturnHomeDelayCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GPSSettingsState
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CameraState
static ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Antiflickering
static ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringElectricFrequencyCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringSetModeCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AntiflickeringState
static ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GPSState
static ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PROState
static ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}


// Project common

// Command class Network
static ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t ARCOMMANDS_Decoder_CommonNetworkDisconnectCb = NULL;
static void *ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonNetworkDisconnectCallback (ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonNetworkDisconnectCb = callback;
        ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkEvent
static ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb = callback;
        ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Settings
static ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsAllSettingsCallback (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsResetCallback_t ARCOMMANDS_Decoder_CommonSettingsResetCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsResetCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsResetCallback (ARCOMMANDS_Decoder_CommonSettingsResetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsResetCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsResetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t ARCOMMANDS_Decoder_CommonSettingsProductNameCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsProductNameCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsProductNameCallback (ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsProductNameCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsProductNameCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t ARCOMMANDS_Decoder_CommonSettingsCountryCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsCountryCallback (ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsCountryCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsAutoCountryCallback (ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SettingsState
static ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Common
static ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t ARCOMMANDS_Decoder_CommonCommonAllStatesCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonAllStatesCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonAllStatesCallback (ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonAllStatesCb = callback;
        ARCOMMANDS_Decoder_CommonCommonAllStatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t ARCOMMANDS_Decoder_CommonCommonCurrentDateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonCurrentDateCallback (ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonCurrentDateCb = callback;
        ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonCurrentTimeCallback (ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb = callback;
        ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonRebootCallback_t ARCOMMANDS_Decoder_CommonCommonRebootCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonRebootCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonRebootCallback (ARCOMMANDS_Decoder_CommonCommonRebootCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonRebootCb = callback;
        ARCOMMANDS_Decoder_CommonCommonRebootCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CommonState
static ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class OverHeat
static ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatSwitchOffCallback (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t ARCOMMANDS_Decoder_CommonOverHeatVentilateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatVentilateCallback (ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatVentilateCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class OverHeatState
static ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class ControllerState
static ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCallback_t ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonControllerStateIsPilotingChangedCallback (ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCb = callback;
        ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class WifiSettings
static ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonWifiSettingsOutdoorSettingCallback (ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb = callback;
        ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class WifiSettingsState
static ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Mavlink
static ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t ARCOMMANDS_Decoder_CommonMavlinkStartCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStartCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStartCallback (ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStartCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStartCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t ARCOMMANDS_Decoder_CommonMavlinkPauseCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkPauseCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkPauseCallback (ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkPauseCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkPauseCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t ARCOMMANDS_Decoder_CommonMavlinkStopCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStopCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStopCallback (ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStopCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStopCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MavlinkState
static ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Calibration
static ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationMagnetoCalibrationCallback (ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CalibrationState
static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CameraSettingsState
static ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GPS
static ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb = NULL;
static void *ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonGPSControllerPositionForRunCallback (ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb = callback;
        ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class FlightPlanState
static ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class FlightPlanEvent
static ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class ARLibsVersionsState
static ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}


// Project JumpingSumo

// Command class Piloting
static ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingPCMDCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingPostureCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingAddCapOffsetCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingState
static ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Animations
static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpStopCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpCancelCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpLoadCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsSimpleAnimationCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AnimationsState
static ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Settings

// Command class SettingsState
static ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCallback (ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecord
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordPictureCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordVideoCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordPictureV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordVideoV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecordState
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecordEvent
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkSettings
static ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkSettingsState
static ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Network
static ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkWifiScanCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class NetworkState
static ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AudioSettings
static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsMasterVolumeCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsThemeCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AudioSettingsState
static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class RoadPlan
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanAllScriptsMetadataCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanScriptUploadedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanScriptDeleteCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanPlayScriptCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class RoadPlanState
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SpeedSettings
static ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCallback_t ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsOutdoorCallback (ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SpeedSettingsState
static ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCallback (ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaStreaming
static ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaStreamingState
static ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}


// Project MiniDrone

// Command class Piloting
static ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCallback_t ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingFlatTrimCallback (ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCallback_t ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingTakeOffCallback (ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingPCMDCallback_t ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingPCMDCallback (ARCOMMANDS_Decoder_MiniDronePilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingLandingCallback_t ARCOMMANDS_Decoder_MiniDronePilotingLandingCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingLandingCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingLandingCallback (ARCOMMANDS_Decoder_MiniDronePilotingLandingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingLandingCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingLandingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCallback_t ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingEmergencyCallback (ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCallback_t ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingAutoTakeOffModeCallback (ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingState
static ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Animations
static ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCallback_t ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneAnimationsFlipCallback (ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb = callback;
        ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneAnimationsCapCallback_t ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneAnimationsCapCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneAnimationsCapCallback (ARCOMMANDS_Decoder_MiniDroneAnimationsCapCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb = callback;
        ARCOMMANDS_Decoder_MiniDroneAnimationsCapCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecord
static ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCallback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordPictureCallback (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordPictureV2Callback (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecordState
static ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class MediaRecordEvent
static ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingSettings
static ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsMaxAltitudeCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsMaxTiltCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class PilotingSettingsState
static ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SpeedSettings
static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxRotationSpeedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsWheelsCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SpeedSettingsState
static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Settings
static ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsCutOutModeCallback (ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SettingsState
static ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCallback (ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCallback (ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCallback (ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class FloodControlState
static ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCallback_t ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCallback (ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GPS
static ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCallback_t ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneGPSControllerLatitudeForRunCallback (ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb = callback;
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCallback_t ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneGPSControllerLongitudeForRunCallback (ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb = callback;
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}


// Project SkyController

// Command class WifiState
static ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Wifi
static ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCallback_t ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiRequestWifiListCallback (ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCallback_t ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiRequestCurrentWifiCallback (ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCallback_t ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiConnectToWifiCallback (ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCallback_t ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiForgetWifiCallback (ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCallback_t ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiWifiAuthChannelCallback (ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Device
static ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceRequestDeviceListCallback (ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceRequestCurrentDeviceCallback (ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceConnectToDeviceCallback (ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class DeviceState
static ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCallback (ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCallback (ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Settings
static ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsAllSettingsCallback (ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerSettingsResetCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsResetCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsResetCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsResetCallback (ARCOMMANDS_Decoder_SkyControllerSettingsResetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsResetCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsResetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SettingsState
static ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Common
static ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCallback_t ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCommonAllStatesCallback (ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CommonState
static ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCallback_t ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCallback (ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class SkyControllerState
static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AccessPointSettings
static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsAccessPointSSIDCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsAccessPointChannelCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AccessPointSettingsState
static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Camera
static ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCallback_t ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCameraResetOrientationCallback (ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GamepadInfos
static ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCallback_t ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosGetGamepadControlsCallback (ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class GamepadInfosState
static ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCallback_t ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCallback (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb = callback;
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCallback_t ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCallback (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class ButtonMappings
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsGetCurrentButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsGetAvailableButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsSetButtonMappingCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsDefaultButtonMappingCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class ButtonMappingsState
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AxisMappings
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsGetCurrentAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsGetAvailableAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsSetAxisMappingCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsDefaultAxisMappingCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AxisMappingsState
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AxisFilters
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersGetCurrentAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersGetPresetAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersSetAxisFilterCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersDefaultAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class AxisFiltersState
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CoPiloting
static ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCallback_t ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCoPilotingSetPilotingSourceCallback (ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CoPilotingState
static ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCallback_t ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCallback (ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class Calibration
static ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback_t ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback (ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Command class CalibrationState
static ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCallback_t ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCallback (ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
static ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback_t ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}


// DECODER ENTRY POINT
eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DecodeBuffer (uint8_t *buffer, int32_t buffLen)
{
    eARCOMMANDS_ID_PROJECT commandProject = -1;
    int commandClass = -1;
    int commandId = -1;
    int32_t error = 0;
    int32_t offset = 0;
    eARCOMMANDS_DECODER_ERROR retVal = ARCOMMANDS_DECODER_OK;
    if (NULL == buffer)
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    } // No else --> Arg check

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        if (ARCOMMANDS_Decoder_Init () == 0)
        {
            retVal = ARCOMMANDS_DECODER_ERROR;
        } // No else --> keep retVal to OK if init went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandProject = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandClass = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandId = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        switch (commandProject)
        {
        case ARCOMMANDS_ID_PROJECT_ARDRONE3:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb != NULL)
                    {
                        uint8_t _flag;
                        int8_t _roll;
                        int8_t _pitch;
                        int8_t _yaw;
                        int8_t _gaz;
                        float _psi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _gaz =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _psi = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb (_flag, _roll, _pitch, _yaw, _gaz, _psi, ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb != NULL)
                    {
                        uint8_t _start;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb (_start, ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb != NULL)
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb (_direction, ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb != NULL)
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb != NULL)
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD _record;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb (_record, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb != NULL)
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state;
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _reason = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb (_state, _reason, ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb != NULL)
                    {
                        float _speedX;
                        float _speedY;
                        float _speedZ;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb (_speedX, _speedY, _speedZ, ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb != NULL)
                    {
                        float _roll;
                        float _pitch;
                        float _yaw;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb (_roll, _pitch, _yaw, ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb != NULL)
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb != NULL)
                    {
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb (_altitude, ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb (_band, ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb != NULL)
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb != NULL)
                    {
                        uint8_t _on;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _on = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb (_on, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb != NULL)
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb != NULL)
                    {
                        uint8_t _shouldNotFlyOver;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _shouldNotFlyOver = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb (_shouldNotFlyOver, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb != NULL)
                    {
                        uint8_t _on;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _on = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb (_on, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb != NULL)
                    {
                        uint8_t _shouldNotFlyOver;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _shouldNotFlyOver = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (_shouldNotFlyOver, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb != NULL)
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb (_present, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb != NULL)
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb (_outdoor, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb != NULL)
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb (_present, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb != NULL)
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb (_outdoor, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb != NULL)
                    {
                        uint8_t _motor_number;
                        char * _type = NULL;
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motor_number = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb (_motor_number, _type, _software, _hardware, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb != NULL)
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb != NULL)
                    {
                        uint8_t _motorIds;
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorIds = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorError = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb (_motorIds, _motorError, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb != NULL)
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb (_version, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb != NULL)
                    {
                        uint16_t _nbFlights;
                        uint16_t _lastFlightDuration;
                        uint32_t _totalFlightDuration;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbFlights = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastFlightDuration = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _totalFlightDuration = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb (_nbFlights, _lastFlightDuration, _totalFlightDuration, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorError = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb (_motorError, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb != NULL)
                    {
                        char * _serialID = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serialID = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb (_serialID, ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODE:
            {
                switch (commandId)
                {
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODESTATE:
            {
                switch (commandId)
                {
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODESTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb != NULL)
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb != NULL)
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb != NULL)
                    {
                        uint8_t _enabled;
                        float _interval;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _interval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb (_enabled, _interval, ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb != NULL)
                    {
                        uint8_t _enabled;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb (_enabled, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb != NULL)
                    {
                        float _value;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb (_value, _min, _max, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb != NULL)
                    {
                        float _value;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb (_value, _min, _max, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb != NULL)
                    {
                        uint8_t _enabled;
                        float _interval;
                        float _minInterval;
                        float _maxInterval;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _interval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _minInterval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _maxInterval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb (_enabled, _interval, _minInterval, _maxInterval, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb != NULL)
                    {
                        uint8_t _enabled;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb (_enabled, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb != NULL)
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        double _horizontalAccuracy;
                        double _verticalAccuracy;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontalAccuracy = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _verticalAccuracy = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb (_latitude, _longitude, _altitude, _horizontalAccuracy, _verticalAccuracy, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb != NULL)
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb (_delay, ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb != NULL)
                    {
                        uint8_t _fixed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fixed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb (_fixed, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb != NULL)
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb (_delay, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb != NULL)
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb (_frequency, ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb (_frequency, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb != NULL)
                    {
                        uint8_t _numberOfSatellite;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _numberOfSatellite = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb (_numberOfSatellite, ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type;
                        uint8_t _available;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _available = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb (_type, _available, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb != NULL)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb != NULL)
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb (_features, ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_ARDRONE3 */
        case ARCOMMANDS_ID_PROJECT_COMMON:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonNetworkDisconnectCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonNetworkDisconnectCb (ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORK */
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb != NULL)
                    {
                        eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _cause = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb (_cause, ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsResetCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsResetCb (ARCOMMANDS_Decoder_CommonSettingsResetCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsProductNameCb != NULL)
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsProductNameCb (_name, ARCOMMANDS_Decoder_CommonSettingsProductNameCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsCountryCb != NULL)
                    {
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsCountryCb (_code, ARCOMMANDS_Decoder_CommonSettingsCountryCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb != NULL)
                    {
                        uint8_t _automatic;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _automatic = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb (_automatic, ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb != NULL)
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb (_name, ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb != NULL)
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb != NULL)
                    {
                        char * _high = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _high = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb (_high, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb != NULL)
                    {
                        char * _low = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _low = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb (_low, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb != NULL)
                    {
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb (_code, ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb != NULL)
                    {
                        uint8_t _automatic;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _automatic = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb (_automatic, ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonAllStatesCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonAllStatesCb (ARCOMMANDS_Decoder_CommonCommonAllStatesCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonCurrentDateCb != NULL)
                    {
                        char * _date = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _date = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonCurrentDateCb (_date, ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb != NULL)
                    {
                        char * _time = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _time = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb (_time, ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonRebootCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonRebootCb (ARCOMMANDS_Decoder_CommonCommonRebootCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMON */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb != NULL)
                    {
                        uint8_t _percent;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _percent = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb (_percent, ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb != NULL)
                    {
                        uint8_t _mass_storage_id;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb (_mass_storage_id, _name, ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb != NULL)
                    {
                        uint8_t _mass_storage_id;
                        uint32_t _size;
                        uint32_t _used_size;
                        uint8_t _plugged;
                        uint8_t _full;
                        uint8_t _internal;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _size = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _used_size = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _plugged = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _full = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _internal = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb (_mass_storage_id, _size, _used_size, _plugged, _full, _internal, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb != NULL)
                    {
                        char * _date = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _date = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb (_date, ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb != NULL)
                    {
                        char * _time = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _time = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb (_time, ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb != NULL)
                    {
                        uint32_t _free_space;
                        uint16_t _rec_time;
                        uint32_t _photo_remaining;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _free_space = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rec_time = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _photo_remaining = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb (_free_space, _rec_time, _photo_remaining, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb != NULL)
                    {
                        int16_t _rssi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb (_rssi, ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb != NULL)
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName;
                        uint8_t _sensorState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _sensorName = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _sensorState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb (_sensorName, _sensorState, ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF */
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonOverHeatVentilateCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonOverHeatVentilateCb (ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED */
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb != NULL)
                    {
                        uint8_t _regulationType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _regulationType = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb (_regulationType, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CONTROLLERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CONTROLLERSTATE_CMD_ISPILOTINGCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCb != NULL)
                    {
                        uint8_t _piloting;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _piloting = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCb (_piloting, ARCOMMANDS_Decoder_CommonControllerStateIsPilotingChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CONTROLLERSTATE_CMD_ISPILOTINGCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CONTROLLERSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb != NULL)
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb (_outdoor, ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb != NULL)
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb (_outdoor, ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonMavlinkStartCb != NULL)
                    {
                        char * _filepath = NULL;
                        eARCOMMANDS_COMMON_MAVLINK_START_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filepath = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonMavlinkStartCb (_filepath, _type, ARCOMMANDS_Decoder_CommonMavlinkStartCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonMavlinkPauseCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonMavlinkPauseCb (ARCOMMANDS_Decoder_CommonMavlinkPauseCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonMavlinkStopCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonMavlinkStopCb (ARCOMMANDS_Decoder_CommonMavlinkStopCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINK */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb != NULL)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state;
                        char * _filepath = NULL;
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filepath = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb (_state, _filepath, _type, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb != NULL)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb (_error, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb != NULL)
                    {
                        uint8_t _calibrate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrate = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb (_calibrate, ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb != NULL)
                    {
                        uint8_t _xAxisCalibration;
                        uint8_t _yAxisCalibration;
                        uint8_t _zAxisCalibration;
                        uint8_t _calibrationFailed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _xAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _zAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrationFailed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb (_xAxisCalibration, _yAxisCalibration, _zAxisCalibration, _calibrationFailed, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb != NULL)
                    {
                        uint8_t _required;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _required = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb (_required, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb != NULL)
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (_axis, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb != NULL)
                    {
                        uint8_t _started;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _started = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb (_started, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb != NULL)
                    {
                        float _fov;
                        float _panMax;
                        float _panMin;
                        float _tiltMax;
                        float _tiltMin;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fov = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _panMax = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _panMin = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tiltMax = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tiltMin = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb (_fov, _panMax, _panMin, _tiltMax, _tiltMin, ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb (_latitude, _longitude, ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_GPS */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb != NULL)
                    {
                        uint8_t _AvailabilityState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _AvailabilityState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb (_AvailabilityState, ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb != NULL)
                    {
                        eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component;
                        uint8_t _State;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _component = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _State = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb (_component, _State, ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb != NULL)
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb != NULL)
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb != NULL)
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_COMMON */
        case ARCOMMANDS_ID_PROJECT_JUMPINGSUMO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb != NULL)
                    {
                        uint8_t _flag;
                        int8_t _speed;
                        int8_t _turn;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _turn =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb (_flag, _speed, _turn, ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb (_type, ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb != NULL)
                    {
                        float _offset;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _offset = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb (_offset, ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb (_type, ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID _id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb (_id, ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb (_error, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb != NULL)
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb != NULL)
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD _record;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb (_record, _mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb != NULL)
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb (_band, ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb != NULL)
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb != NULL)
                    {
                        uint8_t _quality;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb (_quality, ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb != NULL)
                    {
                        uint8_t _volume;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _volume = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb (_volume, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME _theme;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _theme = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb (_theme, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb != NULL)
                    {
                        uint8_t _volume;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _volume = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb (_volume, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _theme = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb (_theme, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb (ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb != NULL)
                    {
                        char * _uuid = NULL;
                        char * _md5Hash = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _md5Hash = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb (_uuid, _md5Hash, ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb != NULL)
                    {
                        char * _uuid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb (_uuid, ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb != NULL)
                    {
                        char * _uuid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb (_uuid, ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb != NULL)
                    {
                        char * _uuid = NULL;
                        uint8_t _version;
                        char * _product = NULL;
                        char * _name = NULL;
                        uint64_t _lastModified;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastModified = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb (_uuid, _version, _product, _name, _lastModified, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _resultCode = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb (_resultCode, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _resultCode = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb (_resultCode, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _resultCode = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb (_resultCode, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb != NULL)
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb (_outdoor, ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb != NULL)
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb (_outdoor, ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb != NULL)
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb != NULL)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_JUMPINGSUMO */
        case ARCOMMANDS_ID_PROJECT_MINIDRONE:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb (ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb (ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb != NULL)
                    {
                        uint8_t _flag;
                        int8_t _roll;
                        int8_t _pitch;
                        int8_t _yaw;
                        int8_t _gaz;
                        float _psi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _gaz =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _psi = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb (_flag, _roll, _pitch, _yaw, _gaz, _psi, ARCOMMANDS_Decoder_MiniDronePilotingPCMDCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingLandingCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingLandingCb (ARCOMMANDS_Decoder_MiniDronePilotingLandingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb (ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb != NULL)
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb != NULL)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb != NULL)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb != NULL)
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb != NULL)
                    {
                        eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb (_direction, ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP */
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb != NULL)
                    {
                        int16_t _offset;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _offset =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb (_offset, ARCOMMANDS_Decoder_MiniDroneAnimationsCapCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb != NULL)
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb != NULL)
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb != NULL)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Custom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb != NULL)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb (_current, ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb (_current, ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb (_current, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb != NULL)
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb (_current, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb != NULL)
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb (_present, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb != NULL)
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb != NULL)
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb (_present, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb != NULL)
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb (_enable, ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb != NULL)
                    {
                        uint8_t _motor;
                        char * _type = NULL;
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb (_motor, _type, _software, _hardware, ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb != NULL)
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb != NULL)
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb (_enable, ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb != NULL)
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb (_delay, ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb != NULL)
                    {
                        double _latitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb (_latitude, ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN */
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb != NULL)
                    {
                        double _longitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb (_longitude, ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_GPS */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_MINIDRONE */
        case ARCOMMANDS_ID_PROJECT_SKYCONTROLLER:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb != NULL)
                    {
                        char * _bssid = NULL;
                        char * _ssid = NULL;
                        uint8_t _secured;
                        uint8_t _saved;
                        int32_t _rssi;
                        int32_t _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _bssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _secured = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _saved = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb (_bssid, _ssid, _secured, _saved, _rssi, _frequency, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb != NULL)
                    {
                        char * _ssid = NULL;
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb (_ssid, _status, ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb != NULL)
                    {
                        uint8_t _level;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _level = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb (_level, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb (ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb (ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb != NULL)
                    {
                        char * _bssid = NULL;
                        char * _ssid = NULL;
                        char * _passphrase = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _bssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _passphrase = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb (_bssid, _ssid, _passphrase, ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb != NULL)
                    {
                        char * _ssid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb (_ssid, ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb (ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb (ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb (ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb != NULL)
                    {
                        char * _deviceName = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _deviceName = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb (_deviceName, ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb != NULL)
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb (_name, ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status;
                        char * _deviceName = NULL;
                        uint16_t _deviceProductID;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _deviceName = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _deviceProductID = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb (_status, _deviceName, _deviceProductID, ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb (ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSettingsResetCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSettingsResetCb (ARCOMMANDS_Decoder_SkyControllerSettingsResetCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb (ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb != NULL)
                    {
                        char * _serialNumber = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serialNumber = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb (_serialNumber, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb (ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb != NULL)
                    {
                        uint8_t _percent;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _percent = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb (_percent, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb != NULL)
                    {
                        uint8_t _fixed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fixed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb (_fixed, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb != NULL)
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        float _heading;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _heading = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb (_latitude, _longitude, _altitude, _heading, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb != NULL)
                    {
                        char * _ssid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb (_ssid, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb != NULL)
                    {
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb (_channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb != NULL)
                    {
                        char * _ssid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb (_ssid, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb != NULL)
                    {
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb (_channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb (ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb (ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type;
                        int32_t _id;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb (_type, _id, _name, ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL */
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb != NULL)
                    {
                        int32_t _key_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb (_key_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb != NULL)
                    {
                        int32_t _key_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb (_key_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb != NULL)
                    {
                        char * _mapping_uid = NULL;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb (_mapping_uid, _name, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb != NULL)
                    {
                        int32_t _axis_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb (_axis_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb != NULL)
                    {
                        int32_t _axis_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb (_axis_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb != NULL)
                    {
                        char * _mapping_uid = NULL;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb (_mapping_uid, _name, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb != NULL)
                    {
                        int32_t _axis_id;
                        char * _filter_uid_or_builder = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filter_uid_or_builder = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb (_axis_id, _filter_uid_or_builder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb != NULL)
                    {
                        int32_t _axis_id;
                        char * _filter_uid_or_builder = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filter_uid_or_builder = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb (_axis_id, _filter_uid_or_builder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb != NULL)
                    {
                        char * _filter_uid = NULL;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filter_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb (_filter_uid, _name, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb != NULL)
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE _source;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _source = (eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb (_source, ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _source = (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb (_source, ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb != NULL)
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb (_enable, ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb != NULL)
                    {
                        eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status;
                        uint8_t _X_Quality;
                        uint8_t _Y_Quality;
                        uint8_t _Z_Quality;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _X_Quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _Y_Quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _Z_Quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb (_status, _X_Quality, _Y_Quality, _Z_Quality, ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE */
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE:
                {
                    ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    if (ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb != NULL)
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb (_enabled, ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom);
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_SKYCONTROLLER */
        default:
            retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            break;
        }
    } // No else --> Processing block
    return retVal;
}

eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DescribeBuffer (uint8_t *buffer, int32_t buffLen, char *resString, int32_t stringLen)
{
    eARCOMMANDS_ID_PROJECT commandProject = -1;
    int commandClass = -1;
    int commandId = -1;
    int32_t offset = 0;
    int32_t error = 0;
    int strOffset = 0;
    eARCOMMANDS_DECODER_ERROR retVal = ARCOMMANDS_DECODER_OK;
    if ((NULL == buffer) || (NULL == resString))
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    } // No else --> Arg check

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        if (ARCOMMANDS_Decoder_Init () == 0)
        {
            retVal = ARCOMMANDS_DECODER_ERROR;
        } // No else --> keep retVal to OK if init went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandProject = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandClass = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandId = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK && stringLen > 0)
    {
        resString[0] = '\0';
    }
    else
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    }

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        switch (commandProject)
        {
        case ARCOMMANDS_ID_PROJECT_ARDRONE3:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.FlatTrim:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.TakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | gaz -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | psi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Landing:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Emergency:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.NavigateHome:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.AutoTakeOffMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Animations.Flip:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION arg = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Camera.Orientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Camera.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.Video:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD arg = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.FlatTrimChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.NavigateHomeStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_PrintI32 (" | reason -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.PositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.SpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AttitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AutoTakeOffModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxTilt:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.AbsolutControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | on -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxDistance:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.NoFlyOverMaxDistance:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | shouldNotFlyOver -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxTiltChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AbsolutControlChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | on -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxDistanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | shouldNotFlyOver -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.HullProtection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.Outdoor:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxVerticalSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.HullProtectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.OutdoorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.ProductMotorVersionListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motor_number -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.ProductGPSVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorErrorStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motorIds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR arg = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | motorError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorSoftwareVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorFlightsStatusChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbFlights -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | lastFlightDuration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | totalFlightDuration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorErrorLastErrorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR arg = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | motorError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.P7ID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serialID -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODE:
            {
                switch (commandId)
                {
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.DirectorMode.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODESTATE:
            {
                switch (commandId)
                {
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.DirectorModeState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_DIRECTORMODESTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.PictureFormatSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.AutoWhiteBalanceSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.ExpositionSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.SaturationSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.TimelapseSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | interval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoAutorecordSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.PictureFormatChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.AutoWhiteBalanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.ExpositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.SaturationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.TimelapseChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | interval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | minInterval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | maxInterval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoAutorecordChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.SetHome:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.ResetHome:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.SendControllerGPS:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | horizontalAccuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | verticalAccuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.HomeType:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.ReturnHomeDelay:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.HomeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.ResetHomeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.GPSFixStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fixed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.GPSUpdateStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.HomeTypeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.ReturnHomeDelayChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.Orientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.electricFrequency:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.setMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.electricFrequencyChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.modeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.NumberOfSatelliteChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | numberOfSatellite -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.HomeTypeAvailabilityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | available -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.HomeTypeChosenChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PROState.Features:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PROState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_ARDRONE3 */
        case ARCOMMANDS_ID_PROJECT_COMMON:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Network.Disconnect:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORK */
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.NetworkEvent.Disconnection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE arg = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_PrintI32 (" | cause -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.NetworkEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.AllSettings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.Reset:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.ProductName:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.Country:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.AutoCountry:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | automatic -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.AllSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ResetChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductNameChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductSerialHighChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | high -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductSerialLowChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | low -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.CountryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.AutoCountryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | automatic -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.AllStates:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.CurrentDate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | date -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.CurrentTime:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.Reboot:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMON */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.AllStatesChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.BatteryStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | percent -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageInfoStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | size -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | used_size -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | plugged -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | full -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | internal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CurrentDateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | date -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CurrentTimeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageInfoRemainingListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | free_space -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | rec_time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | photo_remaining -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.WifiSignalChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.SensorsStatesListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME arg = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_PrintI32 (" | sensorName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | sensorState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.SwitchOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF */
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.Ventilate:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.OverHeatChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED */
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.OverHeatRegulationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | regulationType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CONTROLLERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CONTROLLERSTATE_CMD_ISPILOTINGCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ControllerState.isPilotingChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | piloting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CONTROLLERSTATE_CMD_ISPILOTINGCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ControllerState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CONTROLLERSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettings.OutdoorSetting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettingsState.outdoorSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Start:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filepath -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINK_START_TYPE arg = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Pause:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Stop:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINK */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.MavlinkFilePlayingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filepath -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.MavlinkPlayErrorStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.MagnetoCalibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | xAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | yAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | zAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrationFailed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationRequiredState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | required -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS arg = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationStartedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | started -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CameraSettingsState.CameraSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | fov -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | panMax -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | panMin -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | tiltMax -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | tiltMin -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CameraSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.GPS.ControllerPositionForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.GPS.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_GPS */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.AvailabilityStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | AvailabilityState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.ComponentStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT arg = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_PrintI32 (" | component -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | State -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.StartingErrorEvent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.SpeedBridleEvent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.ControllerLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.SkyControllerLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.DeviceLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_COMMON */
        case ARCOMMANDS_ID_PROJECT_JUMPINGSUMO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | turn -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.Posture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.addCapOffset:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | offset -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.PostureChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.JumpStop:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.JumpCancel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.JumpLoad:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.Jump:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.SimpleAnimation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID)ARCOMMANDS_ReadWrite_PrintI32 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.JumpLoadChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.JumpTypeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.JumpMotorProblemChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SettingsState.ProductGPSVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.Video:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.VideoStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.LinkQualityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettings.MasterVolume:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | volume -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettings.Theme:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME arg = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME)ARCOMMANDS_ReadWrite_PrintI32 (" | theme -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettingsState.MasterVolumeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | volume -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettingsState.ThemeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME arg = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME)ARCOMMANDS_ReadWrite_PrintI32 (" | theme -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.AllScriptsMetadata:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.ScriptUploaded:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | md5Hash -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.ScriptDelete:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.PlayScript:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.ScriptMetadataListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | lastModified -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.AllScriptsMetadataChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.ScriptUploadChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE arg = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_PrintI32 (" | resultCode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.ScriptDeleteChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE arg = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_PrintI32 (" | resultCode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.PlayScriptChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE arg = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_PrintI32 (" | resultCode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettings.Outdoor:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettingsState.OutdoorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_JUMPINGSUMO */
        case ARCOMMANDS_ID_PROJECT_MINIDRONE:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.FlatTrim:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.TakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | gaz -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | psi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.Landing:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.Emergency:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.AutoTakeOffMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.FlatTrimChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.AutoTakeOffModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Animations.Flip:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION arg = (eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP */
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Animations.Cap:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | offset -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.MaxAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.MaxTilt:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.MaxAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.MaxTiltChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.MaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.MaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.Wheels:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.MaxVerticalSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.MaxRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.WheelsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Settings.CutOutMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.ProductMotorsVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.ProductInertialVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.CutOutModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.FloodControlState.FloodControlChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.FloodControlState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.GPS.ControllerLatitudeForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN */
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.GPS.ControllerLongitudeForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.GPS.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_GPS */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_MINIDRONE */
        case ARCOMMANDS_ID_PROJECT_SKYCONTROLLER:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.WifiList:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | bssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | secured -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | saved -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.ConnexionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS arg = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.WifiSignalChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | level -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.RequestWifiList:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.RequestCurrentWifi:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.ConnectToWifi:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | bssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | passphrase -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.ForgetWifi:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.RequestDeviceList:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.RequestCurrentDevice:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.ConnectToDevice:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | deviceName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.DeviceState.DeviceList:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.DeviceState.ConnexionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS arg = (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | deviceName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | deviceProductID -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.DeviceState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Settings.AllSettings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Settings.Reset:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.AllSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.ResetChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.ProductSerialChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serialNumber -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Common.AllStates:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CommonState.AllStatesChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CommonState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.BatteryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | percent -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.GpsFixChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fixed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.GpsPositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | heading -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.AccessPointSSID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.AccessPointChannel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.AccessPointSSIDChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.AccessPointChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Camera.ResetOrientation:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Camera.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfos.getGamepadControls:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfos.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfosState.gamepadControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE arg = (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL */
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfosState.allGamepadControlsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfosState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.getCurrentButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.getAvailableButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.setButtonMapping:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | key_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.defaultButtonMapping:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.currentButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | key_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.allCurrentButtonMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.availableButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.allAvailableButtonsMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.getCurrentAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.getAvailableAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.setAxisMapping:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.defaultAxisMapping:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.currentAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.allCurrentAxisMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.availableAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.allAvailableAxisMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.getCurrentAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.getPresetAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.setAxisFilter:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filter_uid_or_builder -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.defaultAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.currentAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filter_uid_or_builder -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.allCurrentFiltersSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.presetAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filter_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.allPresetFiltersSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPiloting.setPilotingSource:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE arg = (eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_PrintI32 (" | source -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPiloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPilotingState.pilotingSource:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE arg = (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_PrintI32 (" | source -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Calibration.enableMagnetoCalibrationQualityUpdates:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Calibration.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CalibrationState.MagnetoCalibrationState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS arg = (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | X_Quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | Y_Quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | Z_Quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE */
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CalibrationState.MagnetoCalibrationQualityUpdatesState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CalibrationState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_PROJECT_SKYCONTROLLER */
        default:
            strOffset = ARCOMMANDS_ReadWrite_WriteString ("UNKNOWN -> Unknown command", resString, stringLen, strOffset);
            retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            break;
        }
    } // No else --> Processing block
    return retVal;
}

// END GENERATED CODE
